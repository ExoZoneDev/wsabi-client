{"version":3,"sources":["webpack:///wsabi-client.min.js","webpack:///webpack/bootstrap b5e8944221dc570e7815?7a1a","webpack:///./ts/index.ts?0c95","webpack:///./ts/src/socket.ts?368e","webpack:///./~/events/events.js?7c71","webpack:///./ts/src/client.ts?b74d","webpack:///./~/rxjs/Observable.js?4e06","webpack:///./~/rxjs/util/root.js?93c3","webpack:///(webpack)/buildin/module.js?c3c2","webpack:///./~/rxjs/util/toSubscriber.js?f8fe","webpack:///./~/rxjs/Subscriber.js?215e","webpack:///./~/rxjs/util/isFunction.js?51c0","webpack:///./~/rxjs/Subscription.js?5c58","webpack:///./~/rxjs/util/isArray.js?b0ea","webpack:///./~/rxjs/util/isObject.js?aa2e","webpack:///./~/rxjs/util/tryCatch.js?7694","webpack:///./~/rxjs/util/errorObject.js?f49b","webpack:///./~/rxjs/util/UnsubscriptionError.js?bc9d","webpack:///./~/rxjs/Observer.js?f098","webpack:///./~/rxjs/symbol/rxSubscriber.js?112c","webpack:///./~/symbol-observable/index.js?6982","webpack:///./~/symbol-observable/ponyfill.js?f800","webpack:///./~/rxjs/add/observable/fromEvent.js?b3f9","webpack:///./~/rxjs/observable/fromEvent.js?3895","webpack:///./~/rxjs/observable/FromEventObservable.js?5481"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","socket_1","WsabiSocket","client_1","WsabiClient","__extends","this","d","b","__","constructor","hasOwnProperty","prototype","Object","create","events_1","_super","url","messageId","waiting","reconnecting","forceClose","connect","_this","_socket","WebSocket","addEventListener","ping","res","_handleSocketMessage","data","setTimeout","console","log","close","match","messageRegex","exec","parseInt","emit","type","slice","JSON","parse","_","_handleMessagePacket","warn","Array","isArray","length","readyState","OPEN","send","callback","wait","stringify","isConnected","undefined","EventEmitter","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","er","handler","len","args","i","listeners","error","arguments","Error","apply","addListener","listener","newListener","push","warned","trace","on","once","g","removeListener","fired","list","position","splice","removeAllListeners","key","ret","listenerCount","evlistener","emitter","Observable_1","autoConnect","liveUrl","subscriptions","socket","slugs","keys","put","slug","defineProperty","set","ws","enumerable","configurable","request","method","headers","Promise","resolve","reject","statusCode","then","get","body","post","live","listenConnect","Observable","observer","updateCallback","next","isClient","message","err","root_1","toSubscriber_1","$$observable","subscribe","_isScalar","_subscribe","lift","operator","observable","source","observerOrNext","complete","sink","toSubscriber","add","syncErrorThrowable","syncErrorThrown","syncErrorValue","forEach","PromiseCtor","root","Rx","config","subscription","value","unsubscribe","subscriber","global","objectTypes","boolean","function","object","number","string","self","window","freeGlobal","nodeType","webpackPolyfill","deprecate","paths","children","nextOrObserver","Subscriber_1","Subscriber","rxSubscriber_1","$$rxSubscriber","isFunction_1","Subscription_1","Observer_1","destinationOrNext","isStopped","destination","empty","SafeSubscriber","_next","_error","_complete","isUnsubscribed","Subscription","_parent","context","bind","_context","__tryOrSetError","__tryOrUnsub","fn","parent","_unsubscribe","x","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_a","_subscriptions","trial","tryCatch","errorObject","e","index","sub","UnsubscriptionError","concat","teardown","EMPTY","remove","subscriptionIndex","indexOf","tryCatcher","tryCatchTarget","name","map","toString","join","Symbol","result","fromEvent_1","fromEvent","FromEventObservable_1","FromEventObservable","isNodeStyleEventEmmitter","sourceObj","isJQueryStyleEventEmitter","off","isNodeList","isHTMLCollection","isEventTarget","removeEventListener","eventName","selector","target","setupSubscription","_i"],"mappings":"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","file":"wsabi-client.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar socket_1 = __webpack_require__(1);\r\n\texports.WsabiSocket = socket_1.WsabiSocket;\r\n\tvar client_1 = __webpack_require__(3);\r\n\texports.WsabiClient = client_1.WsabiClient;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar events_1 = __webpack_require__(2);\r\n\tvar WsabiSocket = (function (_super) {\r\n\t    __extends(WsabiSocket, _super);\r\n\t    function WsabiSocket(url) {\r\n\t        _super.call(this);\r\n\t        this.url = url;\r\n\t        this.messageId = 0;\r\n\t        this.waiting = {};\r\n\t        this.reconnecting = false;\r\n\t        this.forceClose = false;\r\n\t    }\r\n\t    WsabiSocket.prototype.connect = function () {\r\n\t        var _this = this;\r\n\t        this._socket = new WsabiSocket.WebSocket(this.url + \"/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0\");\r\n\t        this._socket.addEventListener(\"open\", function () {\r\n\t            _this.ping();\r\n\t        });\r\n\t        this._socket.addEventListener(\"message\", function (res) { return _this._handleSocketMessage(res.data); });\r\n\t        this._socket.addEventListener(\"close\", function (res) {\r\n\t            if (_this.forceClose) {\r\n\t                _this.forceClose = false;\r\n\t                return;\r\n\t            }\r\n\t            _this.reconnecting = true;\r\n\t            setTimeout(function () {\r\n\t                _this.connect();\r\n\t            }, 10000);\r\n\t        });\r\n\t        this._socket.addEventListener(\"error\", function (res) {\r\n\t            console.log(\"ERROR:\", res);\r\n\t        });\r\n\t    };\r\n\t    WsabiSocket.prototype.close = function () {\r\n\t        this.forceClose = true;\r\n\t        this._socket.close();\r\n\t    };\r\n\t    WsabiSocket.prototype._handleSocketMessage = function (res) {\r\n\t        var match = WsabiSocket.messageRegex.exec(res);\r\n\t        switch (parseInt(match[1])) {\r\n\t            case 0:\r\n\t                if (this.reconnecting) {\r\n\t                    this.reconnecting = false;\r\n\t                    this.emit(\"reopen\");\r\n\t                }\r\n\t                this.emit(\"open\");\r\n\t                break;\r\n\t            case 1:\r\n\t                this.close();\r\n\t                break;\r\n\t            case 3:\r\n\t                this.emit(\"pong\");\r\n\t                break;\r\n\t            case 4:\r\n\t                var type = parseInt(match[2][0]);\r\n\t                var id = parseInt(match[2].slice(1));\r\n\t                var data = void 0;\r\n\t                try {\r\n\t                    data = JSON.parse(match[3]);\r\n\t                }\r\n\t                catch (_) {\r\n\t                    data = match[3];\r\n\t                }\r\n\t                this._handleMessagePacket(type, id, data);\r\n\t                break;\r\n\t            default:\r\n\t                console.warn(\"Unsupported packet id\", match[1]);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype._handleMessagePacket = function (type, id, data) {\r\n\t        switch (type) {\r\n\t            case 2:\r\n\t                if (Array.isArray(data) && data.length == 2) {\r\n\t                    this.emit(data[0], data[1]);\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"message\", data);\r\n\t                }\r\n\t                break;\r\n\t            case 3:\r\n\t                if (this.waiting[id] != null) {\r\n\t                    this.waiting[id].call(this, data);\r\n\t                    delete this.waiting[id];\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"response\", {\r\n\t                        id: id,\r\n\t                        data: data\r\n\t                    });\r\n\t                }\r\n\t                break;\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.ping = function () {\r\n\t        var _this = this;\r\n\t        if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n\t            this._socket.send(\"2\");\r\n\t            setTimeout(function () {\r\n\t                _this.ping();\r\n\t            }, 50000);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.send = function (data, callback) {\r\n\t        var id = ++this.messageId;\r\n\t        if (callback != null) {\r\n\t            this.wait(id, callback);\r\n\t        }\r\n\t        this._socket.send((\"42\" + id) + JSON.stringify(data));\r\n\t    };\r\n\t    WsabiSocket.prototype.wait = function (id, callback) {\r\n\t        this.waiting[id] = callback;\r\n\t    };\r\n\t    WsabiSocket.prototype.isConnected = function () {\r\n\t        return this._socket.readyState === this._socket.OPEN;\r\n\t    };\r\n\t    WsabiSocket.WebSocket = typeof (WebSocket) === \"function\" ? WebSocket : undefined;\r\n\t    WsabiSocket.messageRegex = /(\\d)(\\d*)(.*)/;\r\n\t    return WsabiSocket;\r\n\t}(events_1.EventEmitter));\r\n\texports.WsabiSocket = WsabiSocket;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar socket_1 = __webpack_require__(1);\r\n\tvar Observable_1 = __webpack_require__(4);\r\n\t__webpack_require__(20);\r\n\tvar WsabiClient = (function () {\r\n\t    function WsabiClient(url, autoConnect) {\r\n\t        var _this = this;\r\n\t        if (autoConnect === void 0) { autoConnect = true; }\r\n\t        this.liveUrl = \"/live\";\r\n\t        this.subscriptions = {};\r\n\t        this.socket = new socket_1.WsabiSocket(url);\r\n\t        // Resub to live events on reconnect.\r\n\t        this.socket.on(\"reopen\", function () {\r\n\t            var slugs = Object.keys(_this.subscriptions);\r\n\t            for (var i = 0, len = slugs.length; i < len; i++) {\r\n\t                _this.put(_this.liveUrl, { slug: slugs[i] });\r\n\t            }\r\n\t        });\r\n\t        if (autoConnect) {\r\n\t            this.connect();\r\n\t        }\r\n\t    }\r\n\t    Object.defineProperty(WsabiClient, \"WebSocket\", {\r\n\t        set: function (ws) {\r\n\t            socket_1.WsabiSocket.WebSocket = ws;\r\n\t        },\r\n\t        enumerable: true,\r\n\t        configurable: true\r\n\t    });\r\n\t    WsabiClient.prototype.connect = function () {\r\n\t        this.socket.connect();\r\n\t    };\r\n\t    WsabiClient.prototype.request = function (method, url, data, headers) {\r\n\t        var _this = this;\r\n\t        if (data === void 0) { data = {}; }\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return new WsabiClient.Promise(function (resolve, reject) {\r\n\t            if (!_this.socket.isConnected()) {\r\n\t                _this.socket.once(\"open\", function () {\r\n\t                    _this.socket.send([\r\n\t                        method,\r\n\t                        {\r\n\t                            method: method,\r\n\t                            headers: headers,\r\n\t                            url: url,\r\n\t                            data: data\r\n\t                        }\r\n\t                    ], function (data) {\r\n\t                        if (data[0].statusCode >= 200 && data[0].statusCode < 400) {\r\n\t                            resolve(data);\r\n\t                        }\r\n\t                        else {\r\n\t                            reject(data[0]);\r\n\t                        }\r\n\t                    });\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                _this.socket.send([\r\n\t                    method,\r\n\t                    {\r\n\t                        method: method,\r\n\t                        headers: headers,\r\n\t                        url: url,\r\n\t                        data: data\r\n\t                    }\r\n\t                ], function (data) {\r\n\t                    if (data[0].statusCode >= 200 && data[0].statusCode < 400) {\r\n\t                        resolve(data);\r\n\t                    }\r\n\t                    else {\r\n\t                        reject(data[0]);\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        }).then(function (res) {\r\n\t            return res[0];\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.get = function (url, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"get\", url, {}, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.post = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"post\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.put = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"put\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.delete = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"delete\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.live = function (slug, listenConnect) {\r\n\t        var _this = this;\r\n\t        if (listenConnect === void 0) { listenConnect = false; }\r\n\t        if (this.subscriptions[slug] == null) {\r\n\t            this.subscriptions[slug] = 0;\r\n\t        }\r\n\t        return Observable_1.Observable.create(function (observer) {\r\n\t            var updateCallback = function (data) { return observer.next(data); };\r\n\t            if (_this.subscriptions[slug] === 0) {\r\n\t                // Not yet subscribed\r\n\t                _this.put(_this.liveUrl, { slug: slug })\r\n\t                    .then(function (res) {\r\n\t                    if (listenConnect) {\r\n\t                        observer.next({\r\n\t                            isClient: true,\r\n\t                            message: \"subscribed\",\r\n\t                            data: res\r\n\t                        });\r\n\t                    }\r\n\t                    _this.subscriptions[slug]++;\r\n\t                    _this.socket.on(slug, updateCallback);\r\n\t                })\r\n\t                    .catch(function (err) { return observer.error(err); });\r\n\t            }\r\n\t            else {\r\n\t                // Already subscribed, just listen for the event.\r\n\t                if (listenConnect) {\r\n\t                    observer.next({\r\n\t                        isClient: true,\r\n\t                        message: \"resubscribed\"\r\n\t                    });\r\n\t                }\r\n\t                _this.subscriptions[slug]++;\r\n\t                _this.socket.on(slug, updateCallback);\r\n\t            }\r\n\t            // Cleanup listener and delete subscription if last listener on unsub.\r\n\t            return function () {\r\n\t                _this.subscriptions[slug]--;\r\n\t                _this.socket.removeListener(slug, updateCallback);\r\n\t                if (_this.subscriptions[slug] === 0) {\r\n\t                    _this.delete(_this.liveUrl, { slug: slug });\r\n\t                }\r\n\t            };\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.Promise = typeof Promise === \"function\" ? Promise : undefined;\r\n\t    return WsabiClient;\r\n\t}());\r\n\texports.WsabiClient = WsabiClient;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(5);\n\tvar toSubscriber_1 = __webpack_require__(7);\n\tvar $$observable = __webpack_require__(18);\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is  called when the Observable is\n\t     * initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or\n\t     * `complete` can be called to notify of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @return {Observable} a new observable with the Operator applied\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    /**\n\t     * Registers handlers for handling emitted values, error and completions from the observable, and\n\t     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n\t     * @method subscribe\n\t     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n\t     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n\t     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n\t     *  the error will be thrown as unhandled\n\t     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n\t     * @return {ISubscription} a subscription reference to the registered handlers\n\t     */\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var operator = this.operator;\n\t        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t        if (operator) {\n\t            operator.call(sink, this);\n\t        }\n\t        else {\n\t            sink.add(this._subscribe(sink));\n\t        }\n\t        if (sink.syncErrorThrowable) {\n\t            sink.syncErrorThrowable = false;\n\t            if (sink.syncErrorThrown) {\n\t                throw sink.syncErrorValue;\n\t            }\n\t        }\n\t        return sink;\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @return {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, PromiseCtor) {\n\t        var _this = this;\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        return new PromiseCtor(function (resolve, reject) {\n\t            var subscription = _this.subscribe(function (value) {\n\t                if (subscription) {\n\t                    // if there is a subscription, then we can surmise\n\t                    // the next handling is asynchronous. Any errors thrown\n\t                    // need to be rejected explicitly and unsubscribe must be\n\t                    // called manually\n\t                    try {\n\t                        next(value);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                        subscription.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    // if there is NO subscription, then we're getting a nexted\n\t                    // value synchronously during subscription. We can just call it.\n\t                    // If it errors, Observable's `subscribe` imple will ensure the\n\t                    // unsubscription logic is called, then synchronously rethrow the error.\n\t                    // After that, Promise will trap the error and send it\n\t                    // down the rejection path.\n\t                    next(value);\n\t                }\n\t            }, reject, resolve);\n\t        });\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source.subscribe(subscriber);\n\t    };\n\t    /**\n\t     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     * @method Symbol.observable\n\t     * @return {Observable} this instance of the observable\n\t     */\n\t    Observable.prototype[$$observable] = function () {\n\t        return this;\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * Creates a new cold Observable by calling the Observable constructor\n\t     * @static true\n\t     * @owner Observable\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @return {Observable} a new cold observable\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t}());\n\texports.Observable = Observable;\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module, global) {\"use strict\";\n\tvar objectTypes = {\n\t    'boolean': false,\n\t    'function': true,\n\t    'object': true,\n\t    'number': false,\n\t    'string': false,\n\t    'undefined': false\n\t};\n\texports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\t/* tslint:disable:no-unused-variable */\n\tvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\tvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\tvar freeGlobal = objectTypes[typeof global] && global;\n\tif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n\t    exports.root = freeGlobal;\n\t}\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Subscriber_1 = __webpack_require__(8);\n\tvar rxSubscriber_1 = __webpack_require__(17);\n\tfunction toSubscriber(nextOrObserver, error, complete) {\n\t    if (nextOrObserver) {\n\t        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t            return nextOrObserver;\n\t        }\n\t        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n\t            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t        }\n\t    }\n\t    if (!nextOrObserver && !error && !complete) {\n\t        return new Subscriber_1.Subscriber();\n\t    }\n\t    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t}\n\texports.toSubscriber = toSubscriber;\n\t//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isFunction_1 = __webpack_require__(9);\n\tvar Subscription_1 = __webpack_require__(10);\n\tvar Observer_1 = __webpack_require__(16);\n\tvar rxSubscriber_1 = __webpack_require__(17);\n\t/**\n\t * Implements the {@link Observer} interface and extends the\n\t * {@link Subscription} class. While the {@link Observer} is the public API for\n\t * consuming the values of an {@link Observable}, all Observers get converted to\n\t * a Subscriber, in order to provide Subscription-like capabilities such as\n\t * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t * implementing operators, but it is rarely used as a public API.\n\t *\n\t * @class Subscriber<T>\n\t */\n\tvar Subscriber = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    /**\n\t     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t     * defined Observer or a `next` callback function.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     */\n\t    function Subscriber(destinationOrNext, error, complete) {\n\t        _super.call(this);\n\t        this.syncErrorValue = null;\n\t        this.syncErrorThrown = false;\n\t        this.syncErrorThrowable = false;\n\t        this.isStopped = false;\n\t        switch (arguments.length) {\n\t            case 0:\n\t                this.destination = Observer_1.empty;\n\t                break;\n\t            case 1:\n\t                if (!destinationOrNext) {\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                }\n\t                if (typeof destinationOrNext === 'object') {\n\t                    if (destinationOrNext instanceof Subscriber) {\n\t                        this.destination = destinationOrNext;\n\t                        this.destination.add(this);\n\t                    }\n\t                    else {\n\t                        this.syncErrorThrowable = true;\n\t                        this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                    }\n\t                    break;\n\t                }\n\t            default:\n\t                this.syncErrorThrowable = true;\n\t                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                break;\n\t        }\n\t    }\n\t    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n\t    /**\n\t     * A static factory for a Subscriber, given a (potentially partial) definition\n\t     * of an Observer.\n\t     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t     * Observer represented by the given arguments.\n\t     */\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber(next, error, complete);\n\t        subscriber.syncErrorThrowable = false;\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `next` from\n\t     * the Observable, with a value. The Observable may call this method 0 or more\n\t     * times.\n\t     * @param {T} [value] The `next` value.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isStopped) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `error` from\n\t     * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t     * the Observable has experienced an error condition.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._error(err);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive a valueless notification of type\n\t     * `complete` from the Observable. Notifies the Observer that the Observable\n\t     * has finished sending push-based notifications.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this.isUnsubscribed) {\n\t            return;\n\t        }\n\t        this.isStopped = true;\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        this.destination.next(value);\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        this.destination.error(err);\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        this.destination.complete();\n\t        this.unsubscribe();\n\t    };\n\t    return Subscriber;\n\t}(Subscription_1.Subscription));\n\texports.Subscriber = Subscriber;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SafeSubscriber = (function (_super) {\n\t    __extends(SafeSubscriber, _super);\n\t    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n\t        _super.call(this);\n\t        this._parent = _parent;\n\t        var next;\n\t        var context = this;\n\t        if (isFunction_1.isFunction(observerOrNext)) {\n\t            next = observerOrNext;\n\t        }\n\t        else if (observerOrNext) {\n\t            context = observerOrNext;\n\t            next = observerOrNext.next;\n\t            error = observerOrNext.error;\n\t            complete = observerOrNext.complete;\n\t            if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                this.add(context.unsubscribe.bind(context));\n\t            }\n\t            context.unsubscribe = this.unsubscribe.bind(this);\n\t        }\n\t        this._context = context;\n\t        this._next = next;\n\t        this._error = error;\n\t        this._complete = complete;\n\t    }\n\t    SafeSubscriber.prototype.next = function (value) {\n\t        if (!this.isStopped && this._next) {\n\t            var _parent = this._parent;\n\t            if (!_parent.syncErrorThrowable) {\n\t                this.__tryOrUnsub(this._next, value);\n\t            }\n\t            else if (this.__tryOrSetError(_parent, this._next, value)) {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._error) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else if (!_parent.syncErrorThrowable) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t            else {\n\t                _parent.syncErrorValue = err;\n\t                _parent.syncErrorThrown = true;\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._complete) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            this.unsubscribe();\n\t            throw err;\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            parent.syncErrorValue = err;\n\t            parent.syncErrorThrown = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    SafeSubscriber.prototype._unsubscribe = function () {\n\t        var _parent = this._parent;\n\t        this._context = null;\n\t        this._parent = null;\n\t        _parent.unsubscribe();\n\t    };\n\t    return SafeSubscriber;\n\t}(Subscriber));\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isFunction(x) {\n\t    return typeof x === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar isArray_1 = __webpack_require__(11);\n\tvar isObject_1 = __webpack_require__(12);\n\tvar isFunction_1 = __webpack_require__(9);\n\tvar tryCatch_1 = __webpack_require__(13);\n\tvar errorObject_1 = __webpack_require__(14);\n\tvar UnsubscriptionError_1 = __webpack_require__(15);\n\t/**\n\t * Represents a disposable resource, such as the execution of an Observable. A\n\t * Subscription has one important method, `unsubscribe`, that takes no argument\n\t * and just disposes the resource held by the subscription.\n\t *\n\t * Additionally, subscriptions may be grouped together through the `add()`\n\t * method, which will attach a child Subscription to the current Subscription.\n\t * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t * will be unsubscribed as well.\n\t *\n\t * @class Subscription\n\t */\n\tvar Subscription = (function () {\n\t    /**\n\t     * @param {function(): void} [unsubscribe] A function describing how to\n\t     * perform the disposal of resources when the `unsubscribe` method is called.\n\t     */\n\t    function Subscription(unsubscribe) {\n\t        /**\n\t         * A flag to indicate whether this Subscription has already been unsubscribed.\n\t         * @type {boolean}\n\t         */\n\t        this.isUnsubscribed = false;\n\t        if (unsubscribe) {\n\t            this._unsubscribe = unsubscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Disposes the resources held by the subscription. May, for instance, cancel\n\t     * an ongoing Observable execution or cancel any other type of work that\n\t     * started when the Subscription was created.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.unsubscribe = function () {\n\t        var hasErrors = false;\n\t        var errors;\n\t        if (this.isUnsubscribed) {\n\t            return;\n\t        }\n\t        this.isUnsubscribed = true;\n\t        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t        this._subscriptions = null;\n\t        if (isFunction_1.isFunction(_unsubscribe)) {\n\t            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t            if (trial === errorObject_1.errorObject) {\n\t                hasErrors = true;\n\t                (errors = errors || []).push(errorObject_1.errorObject.e);\n\t            }\n\t        }\n\t        if (isArray_1.isArray(_subscriptions)) {\n\t            var index = -1;\n\t            var len = _subscriptions.length;\n\t            while (++index < len) {\n\t                var sub = _subscriptions[index];\n\t                if (isObject_1.isObject(sub)) {\n\t                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                    if (trial === errorObject_1.errorObject) {\n\t                        hasErrors = true;\n\t                        errors = errors || [];\n\t                        var err = errorObject_1.errorObject.e;\n\t                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                            errors = errors.concat(err.errors);\n\t                        }\n\t                        else {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (hasErrors) {\n\t            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t        }\n\t    };\n\t    /**\n\t     * Adds a tear down to be called during the unsubscribe() of this\n\t     * Subscription.\n\t     *\n\t     * If the tear down being added is a subscription that is already\n\t     * unsubscribed, is the same reference `add` is being called on, or is\n\t     * `Subscription.EMPTY`, it will not be added.\n\t     *\n\t     * If this subscription is already in an `isUnsubscribed` state, the passed\n\t     * tear down logic will be executed immediately.\n\t     *\n\t     * @param {TeardownLogic} teardown The additional logic to execute on\n\t     * teardown.\n\t     * @return {Subscription} Returns the Subscription used or created to be\n\t     * added to the inner subscriptions list. This Subscription can be used with\n\t     * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t     * list.\n\t     */\n\t    Subscription.prototype.add = function (teardown) {\n\t        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var sub = teardown;\n\t        switch (typeof teardown) {\n\t            case 'function':\n\t                sub = new Subscription(teardown);\n\t            case 'object':\n\t                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n\t                    break;\n\t                }\n\t                else if (this.isUnsubscribed) {\n\t                    sub.unsubscribe();\n\t                }\n\t                else {\n\t                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n\t        }\n\t        return sub;\n\t    };\n\t    /**\n\t     * Removes a Subscription from the internal list of subscriptions that will\n\t     * unsubscribe during the unsubscribe process of this Subscription.\n\t     * @param {Subscription} subscription The subscription to remove.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.remove = function (subscription) {\n\t        // HACK: This might be redundant because of the logic in `add()`\n\t        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.isUnsubscribed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t}());\n\texports.Subscription = Subscription;\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isObject(x) {\n\t    return x != null && typeof x === 'object';\n\t}\n\texports.isObject = isObject;\n\t//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar errorObject_1 = __webpack_require__(14);\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\texports.tryCatch = tryCatch;\n\t;\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// typeof any so that it we don't have to cast when comparing a result to the error object\n\texports.errorObject = { e: {} };\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when one or more errors have occurred during the\n\t * `unsubscribe` of a {@link Subscription}.\n\t */\n\tvar UnsubscriptionError = (function (_super) {\n\t    __extends(UnsubscriptionError, _super);\n\t    function UnsubscriptionError(errors) {\n\t        _super.call(this);\n\t        this.errors = errors;\n\t        this.name = 'UnsubscriptionError';\n\t        this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n\t    }\n\t    return UnsubscriptionError;\n\t}(Error));\n\texports.UnsubscriptionError = UnsubscriptionError;\n\t//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.empty = {\n\t    isUnsubscribed: true,\n\t    next: function (value) { },\n\t    error: function (err) { throw err; },\n\t    complete: function () { }\n\t};\n\t//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(5);\n\tvar Symbol = root_1.root.Symbol;\n\texports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/* global window */\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(19)(global || window || this);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar Symbol = root.Symbol;\n\t\n\t\tif (typeof Symbol === 'function') {\n\t\t\tif (Symbol.observable) {\n\t\t\t\tresult = Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = Symbol('observable');\n\t\t\t\tSymbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\t\n\t\treturn result;\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(4);\n\tvar fromEvent_1 = __webpack_require__(21);\n\tObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar FromEventObservable_1 = __webpack_require__(22);\n\texports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(4);\n\tvar tryCatch_1 = __webpack_require__(13);\n\tvar errorObject_1 = __webpack_require__(14);\n\tvar Subscription_1 = __webpack_require__(10);\n\tfunction isNodeStyleEventEmmitter(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n\t}\n\tfunction isJQueryStyleEventEmitter(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n\t}\n\tfunction isNodeList(sourceObj) {\n\t    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n\t}\n\tfunction isHTMLCollection(sourceObj) {\n\t    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n\t}\n\tfunction isEventTarget(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n\t}\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromEventObservable = (function (_super) {\n\t    __extends(FromEventObservable, _super);\n\t    function FromEventObservable(sourceObj, eventName, selector) {\n\t        _super.call(this);\n\t        this.sourceObj = sourceObj;\n\t        this.eventName = eventName;\n\t        this.selector = selector;\n\t    }\n\t    /**\n\t     * Creates an Observable that emits events of a specific type coming from the\n\t     * given event target.\n\t     *\n\t     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n\t     * EventEmitter events or others.</span>\n\t     *\n\t     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n\t     *\n\t     * Creates an Observable by attaching an event listener to an \"event target\",\n\t     * which may be an object with `addEventListener` and `removeEventListener`,\n\t     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n\t     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n\t     * the output Observable is subscribed, and removed when the Subscription is\n\t     * unsubscribed.\n\t     *\n\t     * @example <caption>Emits clicks happening on the DOM document</caption>\n\t     * var clicks = Rx.Observable.fromEvent(document, 'click');\n\t     * clicks.subscribe(x => console.log(x));\n\t     *\n\t     * @see {@link from}\n\t     * @see {@link fromEventPattern}\n\t     *\n\t     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n\t     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n\t     * @param {string} eventName The event name of interest, being emitted by the\n\t     * `target`.\n\t     * @param {function(...args: any): T} [selector] An optional function to\n\t     * post-process results. It takes the arguments from the event handler and\n\t     * should return a single value.\n\t     * @return {Observable<T>}\n\t     * @static true\n\t     * @name fromEvent\n\t     * @owner Observable\n\t     */\n\t    FromEventObservable.create = function (target, eventName, selector) {\n\t        return new FromEventObservable(target, eventName, selector);\n\t    };\n\t    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n\t        var unsubscribe;\n\t        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n\t            for (var i = 0, len = sourceObj.length; i < len; i++) {\n\t                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n\t            }\n\t        }\n\t        else if (isEventTarget(sourceObj)) {\n\t            sourceObj.addEventListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n\t        }\n\t        else if (isJQueryStyleEventEmitter(sourceObj)) {\n\t            sourceObj.on(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n\t        }\n\t        else if (isNodeStyleEventEmmitter(sourceObj)) {\n\t            sourceObj.addListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n\t        }\n\t        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n\t    };\n\t    FromEventObservable.prototype._subscribe = function (subscriber) {\n\t        var sourceObj = this.sourceObj;\n\t        var eventName = this.eventName;\n\t        var selector = this.selector;\n\t        var handler = selector ? function () {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n\t            if (result === errorObject_1.errorObject) {\n\t                subscriber.error(errorObject_1.errorObject.e);\n\t            }\n\t            else {\n\t                subscriber.next(result);\n\t            }\n\t        } : function (e) { return subscriber.next(e); };\n\t        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n\t    };\n\t    return FromEventObservable;\n\t}(Observable_1.Observable));\n\texports.FromEventObservable = FromEventObservable;\n\t//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wsabi-client.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap b5e8944221dc570e7815\n **/","import {WsabiSocket} from \"./src/socket\";\r\nimport {WsabiClient} from \"./src/client\";\r\n\r\nexport {WsabiSocket, WsabiClient};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/index.ts\n **/","import {EventEmitter} from \"events\";\r\n\r\nexport class WsabiSocket extends EventEmitter {\r\n  public static WebSocket = typeof(WebSocket) === \"function\" ? WebSocket : undefined;\r\n  private static messageRegex = /(\\d)(\\d*)(.*)/;\r\n\r\n  private _socket: WebSocket;\r\n  private messageId = 0;\r\n  private waiting: {\r\n    [key: string]: (data: any) => void;\r\n  } = {};\r\n  private reconnecting: boolean = false;\r\n  private forceClose: boolean = false;\r\n\r\n  constructor(public url: string) {\r\n    super();\r\n  }\r\n\r\n  connect() {\r\n    this._socket = new WsabiSocket.WebSocket(`${this.url}/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0`);\r\n    this._socket.addEventListener(\"open\", () => {\r\n      this.ping();\r\n    });\r\n    this._socket.addEventListener(\"message\", res => this._handleSocketMessage(res.data));\r\n    this._socket.addEventListener(\"close\", res => {\r\n      if (this.forceClose) {\r\n        this.forceClose = false;\r\n        return;\r\n      }\r\n\r\n      this.reconnecting = true;\r\n      setTimeout(() => {\r\n        this.connect();\r\n      }, 10000);\r\n    });\r\n    this._socket.addEventListener(\"error\", res => {\r\n      console.log(\"ERROR:\", res);\r\n    });\r\n  }\r\n\r\n  close() {\r\n    this.forceClose = true;\r\n    this._socket.close();\r\n  }\r\n\r\n  private _handleSocketMessage(res: string) {\r\n    let match = WsabiSocket.messageRegex.exec(res);\r\n    switch (parseInt(match[1])) {\r\n      case 0:\r\n        if (this.reconnecting) {\r\n          this.reconnecting = false;\r\n          this.emit(\"reopen\");\r\n        }\r\n        this.emit(\"open\");\r\n        break;\r\n      case 1:\r\n        this.close();\r\n        break;\r\n      case 3:\r\n        this.emit(\"pong\");\r\n        break;\r\n      case 4:\r\n        let type = parseInt(match[2][0]);\r\n        let id = parseInt(match[2].slice(1));\r\n        let data;\r\n        try {\r\n          data = JSON.parse(match[3]);\r\n        } catch (_) {\r\n          data = match[3];\r\n        }\r\n\r\n        this._handleMessagePacket(type, id, data);\r\n        break;\r\n      default:\r\n        console.warn(\"Unsupported packet id\", match[1]);\r\n    }\r\n  }\r\n\r\n  private _handleMessagePacket(type: number, id: number, data: any) {\r\n    switch (type) {\r\n      case 2:\r\n        if (Array.isArray(data) && data.length == 2) {\r\n          this.emit(data[0], data[1]);\r\n        } else {\r\n          this.emit(\"message\", data);\r\n        }\r\n        break;\r\n      case 3:\r\n        if (this.waiting[id] != null) {\r\n          this.waiting[id].call(this, data);\r\n          delete this.waiting[id];\r\n        } else {\r\n          this.emit(\"response\", {\r\n            id: id,\r\n            data: data\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  private ping() {\r\n    if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n      this._socket.send(\"2\");\r\n      setTimeout(() => {\r\n        this.ping();\r\n      }, 50000);\r\n    }\r\n  }\r\n\r\n  public send(data: any, callback?: (data: any) => void) {\r\n    let id = ++this.messageId;\r\n    if (callback != null) {\r\n      this.wait(id, callback);\r\n    }\r\n\r\n    this._socket.send(`42${id}` + JSON.stringify(data));\r\n  }\r\n\r\n  public wait(id: number, callback?: (data: any) => void) {\r\n    this.waiting[id] = callback;\r\n  }\r\n  \r\n  public isConnected() {\r\n    return this._socket.readyState === this._socket.OPEN;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/src/socket.ts\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 2\n ** module chunks = 0 1\n **/","import {WsabiSocket} from \"./socket\";\r\nimport {Observable} from \"rxjs/Observable\";\r\n\r\nimport \"rxjs/add/observable/fromEvent\";\r\n\r\nexport class WsabiClient {\r\n  public static Promise = typeof Promise === \"function\" ? Promise : undefined;\r\n  public static set WebSocket(ws: any) {\r\n    WsabiSocket.WebSocket = ws;\r\n  }\r\n\r\n  public socket: WsabiSocket;\r\n  public liveUrl: string = \"/live\"\r\n\r\n  private subscriptions: {\r\n    [key: string]: number\r\n  } = {};\r\n\r\n  constructor(url: string, autoConnect: boolean = true) {\r\n    this.socket = new WsabiSocket(url);\r\n    \r\n    // Resub to live events on reconnect.\r\n    this.socket.on(\"reopen\", () => {\r\n      let slugs = Object.keys(this.subscriptions);\r\n      for (let i = 0, len = slugs.length; i < len; i++) {\r\n        this.put(this.liveUrl, { slug: slugs[i] });\r\n      }\r\n    })\r\n\r\n    if (autoConnect) {\r\n      this.connect();\r\n    }\r\n  }\r\n\r\n  public connect() {\r\n    this.socket.connect();\r\n  }\r\n\r\n  public request(method: string, url: string, data: any = {}, headers: any = {}) {\r\n    return new WsabiClient.Promise((resolve, reject) => {\r\n      if (!this.socket.isConnected()) {\r\n        this.socket.once(\"open\", () => {\r\n          this.socket.send([\r\n            method,\r\n            {\r\n              method: method,\r\n              headers: headers,\r\n              url: url,\r\n              data: data\r\n            }\r\n          ], (data) => {\r\n            if (data[0].statusCode >= 200 && data[0].statusCode < 400) {\r\n              resolve(data);\r\n            } else {\r\n              reject(data[0]);\r\n            }\r\n          });\r\n        })\r\n      } else {\r\n        this.socket.send([\r\n          method,\r\n          {\r\n            method: method,\r\n            headers: headers,\r\n            url: url,\r\n            data: data\r\n          }\r\n        ], (data) => {\r\n            if (data[0].statusCode >= 200 && data[0].statusCode < 400) {\r\n              resolve(data);\r\n            } else {\r\n              reject(data[0]);\r\n            }\r\n        });\r\n      }\r\n    }).then(function (res) {\r\n      return res[0];\r\n    });\r\n  }\r\n\r\n  public get(url: string, headers: any = {}) {\r\n    return this.request(\"get\", url, {}, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public post(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"post\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public put(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"put\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public delete(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"delete\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public live(slug: string, listenConnect = false): Observable<any> {\r\n    if (this.subscriptions[slug] == null) {\r\n      this.subscriptions[slug] = 0;\r\n    }\r\n    return Observable.create(observer => {\r\n      const updateCallback = data => observer.next(data);\r\n      if (this.subscriptions[slug] === 0) {\r\n        // Not yet subscribed\r\n        this.put(this.liveUrl, { slug: slug })\r\n          .then((res) => {\r\n            if (listenConnect) {\r\n              observer.next({\r\n                isClient: true,\r\n                message: \"subscribed\",\r\n                data: res\r\n              });\r\n            }\r\n            \r\n            this.subscriptions[slug]++;\r\n            this.socket.on(slug, updateCallback);\r\n          })\r\n          .catch(err => observer.error(err));\r\n      } else {\r\n        // Already subscribed, just listen for the event.\r\n        if (listenConnect) {\r\n          observer.next({\r\n            isClient: true,\r\n            message: \"resubscribed\"\r\n          });\r\n        }\r\n        this.subscriptions[slug]++;\r\n        this.socket.on(slug, updateCallback);\r\n      }\r\n      \r\n      // Cleanup listener and delete subscription if last listener on unsub.\r\n      return () => {\r\n        this.subscriptions[slug]--;\r\n        this.socket.removeListener(slug, updateCallback);\r\n        \r\n        if (this.subscriptions[slug] === 0) {\r\n          this.delete(this.liveUrl, { slug: slug })\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/src/client.ts\n **/","\"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar $$observable = require('symbol-observable');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this);\n        }\n        else {\n            sink.add(this._subscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` imple will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observable.js\n ** module id = 4\n ** module chunks = 0 1\n **/","\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n/* tslint:disable:no-unused-variable */\nvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\nvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/root.js\n ** module id = 5\n ** module chunks = 0 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 6\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber();\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/toSubscriber.js\n ** module id = 7\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscriber.js\n ** module id = 8\n ** module chunks = 0 1\n **/","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isFunction.js\n ** module id = 9\n ** module chunks = 0 1\n **/","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.isUnsubscribed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `isUnsubscribed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n            return;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.isUnsubscribed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.isUnsubscribed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscription.js\n ** module id = 10\n ** module chunks = 0 1\n **/","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isArray.js\n ** module id = 11\n ** module chunks = 0 1\n **/","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isObject.js\n ** module id = 12\n ** module chunks = 0 1\n **/","\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryCatch.js\n ** module id = 13\n ** module chunks = 0 1\n **/","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/errorObject.js\n ** module id = 14\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        this.name = 'UnsubscriptionError';\n        this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/UnsubscriptionError.js\n ** module id = 15\n ** module chunks = 0 1\n **/","\"use strict\";\nexports.empty = {\n    isUnsubscribed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observer.js\n ** module id = 16\n ** module chunks = 0 1\n **/","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/rxSubscriber.js\n ** module id = 17\n ** module chunks = 0 1\n **/","/* global window */\n'use strict';\n\nmodule.exports = require('./ponyfill')(global || window || this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/symbol-observable/index.js\n ** module id = 18\n ** module chunks = 0 1\n **/","'use strict';\n\nmodule.exports = function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/symbol-observable/ponyfill.js\n ** module id = 19\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromEvent.js\n ** module id = 20\n ** module chunks = 0 1\n **/","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromEvent.js\n ** module id = 21\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nfunction isNodeStyleEventEmmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n    }\n    /**\n     * Creates an Observable that emits events of a specific type coming from the\n     * given event target.\n     *\n     * <span class=\"informal\">Creates an Observable from DOM events, or Node\n     * EventEmitter events or others.</span>\n     *\n     * <img src=\"./img/fromEvent.png\" width=\"100%\">\n     *\n     * Creates an Observable by attaching an event listener to an \"event target\",\n     * which may be an object with `addEventListener` and `removeEventListener`,\n     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the\n     * DOM, or an HTMLCollection from the DOM. The event handler is attached when\n     * the output Observable is subscribed, and removed when the Subscription is\n     * unsubscribed.\n     *\n     * @example <caption>Emits clicks happening on the DOM document</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * clicks.subscribe(x => console.log(x));\n     *\n     * @see {@link from}\n     * @see {@link fromEventPattern}\n     *\n     * @param {EventTargetLike} target The DOMElement, event target, Node.js\n     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.\n     * @param {string} eventName The event name of interest, being emitted by the\n     * `target`.\n     * @param {function(...args: any): T} [selector] An optional function to\n     * post-process results. It takes the arguments from the event handler and\n     * should return a single value.\n     * @return {Observable<T>}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (target, eventName, selector) {\n        return new FromEventObservable(target, eventName, selector);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            sourceObj.addEventListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmmitter(sourceObj)) {\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromEventObservable.js\n ** module id = 22\n ** module chunks = 0 1\n **/"],"sourceRoot":""}