{"version":3,"sources":["webpack:///wsabi-client.min.js","webpack:///webpack/bootstrap c87ce24303abda85834c?e8b4","webpack:///./ts/index.ts?0c95","webpack:///./ts/src/socket.ts?368e","webpack:///./~/events/events.js?7c71","webpack:///./ts/src/client.ts?b74d","webpack:///./~/rxjs/Observable.js?4e06","webpack:///./~/rxjs/util/root.js?93c3","webpack:///(webpack)/buildin/module.js?c3c2","webpack:///./~/rxjs/symbol/observable.js?1f24","webpack:///./~/rxjs/util/toSubscriber.js?f8fe","webpack:///./~/rxjs/Subscriber.js?215e","webpack:///./~/rxjs/util/isFunction.js?51c0","webpack:///./~/rxjs/Subscription.js?5c58","webpack:///./~/rxjs/util/isArray.js?b0ea","webpack:///./~/rxjs/util/isObject.js?aa2e","webpack:///./~/rxjs/util/tryCatch.js?7694","webpack:///./~/rxjs/util/errorObject.js?f49b","webpack:///./~/rxjs/util/UnsubscriptionError.js?bc9d","webpack:///./~/rxjs/symbol/rxSubscriber.js?112c","webpack:///./~/rxjs/Observer.js?f098","webpack:///./~/rxjs/add/observable/fromEvent.js?b3f9","webpack:///./~/rxjs/observable/fromEvent.js?3895","webpack:///./~/rxjs/observable/FromEventObservable.js?5481"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","socket_1","WsabiSocket","client_1","WsabiClient","__extends","this","d","b","__","constructor","hasOwnProperty","prototype","Object","create","events_1","_super","url","messageId","waiting","reconnecting","connect","_this","_socket","WebSocket","addEventListener","ping","res","_handleSocketMessage","data","setTimeout","console","log","close","match","messageRegex","exec","parseInt","emit","type","slice","JSON","parse","_","_handleMessagePacket","warn","Array","isArray","length","readyState","OPEN","send","callback","wait","stringify","isConnected","undefined","EventEmitter","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","er","handler","len","args","i","listeners","error","arguments","Error","apply","addListener","listener","newListener","push","warned","trace","on","once","g","removeListener","fired","list","position","splice","removeAllListeners","key","ret","listenerCount","evlistener","emitter","Observable_1","autoConnect","liveUrl","subscriptions","socket","slugs","keys","put","slug","defineProperty","set","ws","enumerable","configurable","request","method","headers","Promise","resolve","reject","statusCode","then","get","body","post","live","listenConnect","Observable","observer","updateCallback","next","isClient","message","err","root_1","observable_1","toSubscriber_1","subscribe","_isScalar","_subscribe","lift","operator","observable","source","observerOrNext","complete","sink","toSubscriber","add","syncErrorThrowable","syncErrorThrown","syncErrorValue","forEach","PromiseCtor","root","Rx","config","subscription","value","unsubscribe","subscriber","$$observable","global","objectTypes","boolean","function","object","number","string","self","window","freeGlobal","nodeType","webpackPolyfill","deprecate","paths","children","Symbol","nextOrObserver","Subscriber_1","Subscriber","rxSubscriber_1","$$rxSubscriber","isFunction_1","Subscription_1","Observer_1","destinationOrNext","isStopped","destination","empty","SafeSubscriber","_next","_error","_complete","isUnsubscribed","Subscription","_parent","context","bind","_context","__tryOrSetError","__tryOrUnsub","fn","parent","_unsubscribe","x","isArray_1","isObject_1","tryCatch_1","errorObject_1","UnsubscriptionError_1","errors","hasErrors","_a","_subscriptions","trial","tryCatch","errorObject","e","index","sub","UnsubscriptionError","concat","teardown","EMPTY","remove","subscriptionIndex","indexOf","tryCatcher","tryCatchTarget","name","map","toString","join","fromEvent_1","fromEvent","FromEventObservable_1","FromEventObservable","isNodeStyleEventEmmitter","sourceObj","isJQueryStyleEventEmitter","off","isNodeList","isHTMLCollection","isEventTarget","removeEventListener","eventName","selector","setupSubscription","_i","result"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/B,YE9CD,IAAAW,GAAAX,EAA0B,EAGlBG,GAAAS,YAAWD,EAAAC,WAFnB,IAAAC,GAAAb,EAA0B,EAELG,GAAAW,YAAWD,EAAAC,aFoD1B,SAASV,EAAQD,EAASH,GAE/B,YACA,IAAIe,GAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAAGC,GAErD,QAASC,KAAOH,KAAKI,YAAcH,EADnC,IAAK,GAAIP,KAAKQ,GAAOA,EAAEG,eAAeX,KAAIO,EAAEP,GAAKQ,EAAER,GAEnDO,GAAEK,UAAkB,OAANJ,EAAaK,OAAOC,OAAON,IAAMC,EAAGG,UAAYJ,EAAEI,UAAW,GAAIH,KG7DpFM,EAAAzB,EAA2B,GAE3BY,EAAA,SAAAc,GAWE,QAAAd,GAAmBe,GACjBD,EAAAnB,KAAAS,MADiBA,KAAAW,MANXX,KAAAY,UAAY,EACZZ,KAAAa,WAGAb,KAAAc,cAAwB,EA4GlC,MArHiCf,GAAAH,EAAAc,GAe/Bd,EAAAU,UAAAS,QAAA,cAAAC,GAAAhB,IACEA,MAAKiB,QAAU,GAAIrB,GAAYsB,UAAalB,KAAKW,IAAG,iEACpDX,KAAKiB,QAAQE,iBAAiB,OAAQ,WACpCH,EAAKI,SAEPpB,KAAKiB,QAAQE,iBAAiB,UAAW,SAACE,GAAQ,MAAAL,GAAKM,qBAAqBD,EAAIE,QAChFvB,KAAKiB,QAAQE,iBAAiB,QAAS,SAACE,GACtCL,EAAKF,cAAe,EACpBU,WAAW,WACTR,EAAKD,WACJ,OAELf,KAAKiB,QAAQE,iBAAiB,QAAS,SAACE,GACtCI,QAAQC,IAAI,SAAUL,MAI1BzB,EAAAU,UAAAqB,MAAA,WACE3B,KAAKiB,QAAQU,SAGP/B,EAAAU,UAAAgB,qBAAR,SAA6BD,GAC3B,GAAIO,GAAQhC,EAAYiC,aAAaC,KAAKT,EAC1C,QAAQU,SAASH,EAAM,KACrB,IAAK,GACC5B,KAAKc,eACPd,KAAKc,cAAe,EACpBd,KAAKgC,KAAK,WAEZhC,KAAKgC,KAAK,OACV,MACF,KAAK,GACHhC,KAAK2B,OACL,MACF,KAAK,GACH3B,KAAKgC,KAAK,OACV,MACF,KAAK,GACH,GAAIC,GAAOF,SAASH,EAAM,GAAG,IACzBvC,EAAK0C,SAASH,EAAM,GAAGM,MAAM,IAC7BX,EAAI,MACR,KACEA,EAAOY,KAAKC,MAAMR,EAAM,IACxB,MAAOS,GACPd,EAAOK,EAAM,GAGf5B,KAAKsC,qBAAqBL,EAAM5C,EAAIkC,EACpC,MACF,SACEE,QAAQc,KAAK,wBAAyBX,EAAM,MAI1ChC,EAAAU,UAAAgC,qBAAR,SAA6BL,EAAc5C,EAAYkC,GACrD,OAAQU,GACN,IAAK,GACCO,MAAMC,QAAQlB,IAAwB,GAAfA,EAAKmB,OAC9B1C,KAAKgC,KAAKT,EAAK,GAAIA,EAAK,IAExBvB,KAAKgC,KAAK,UAAWT,EAEvB,MACF,KAAK,GACqB,MAApBvB,KAAKa,QAAQxB,IACfW,KAAKa,QAAQxB,GAAIE,KAAKS,KAAMuB,SACrBvB,MAAKa,QAAQxB,IAEpBW,KAAKgC,KAAK,YACR3C,GAAIA,EACJkC,KAAMA,MAOR3B,EAAAU,UAAAc,KAAR,cAAAJ,GAAAhB,IACMA,MAAKiB,QAAQ0B,aAAe/C,EAAYsB,UAAU0B,OACpD5C,KAAKiB,QAAQ4B,KAAK,KAClBrB,WAAW,WACTR,EAAKI,QACJ,OAIAxB,EAAAU,UAAAuC,KAAP,SAAYtB,EAAWuB,GACrB,GAAIzD,KAAOW,KAAKY,SACA,OAAZkC,GACF9C,KAAK+C,KAAK1D,EAAIyD,GAGhB9C,KAAKiB,QAAQ4B,KAAK,KAAKxD,EAAO8C,KAAKa,UAAUzB,KAGxC3B,EAAAU,UAAAyC,KAAP,SAAY1D,EAAYyD,GACtB9C,KAAKa,QAAQxB,GAAMyD,GAGdlD,EAAAU,UAAA2C,YAAP,WACE,MAAOjD,MAAKiB,QAAQ0B,aAAe3C,KAAKiB,QAAQ2B,MAlHpChD,EAAAsB,UAAkC,kBAAhB,WAA6BA,UAAYgC,OAC1DtD,EAAAiC,aAAe,gBAmHhCjC,GArHiCa,EAAA0C,aAApBhE,GAAAS,YAAWA,GHkLlB,SAASR,EAAQD,GI/JvB,QAAAgE,KACAnD,KAAAoD,QAAApD,KAAAoD,YACApD,KAAAqD,cAAArD,KAAAqD,eAAAH,OAoQA,QAAAI,GAAAC,GACA,wBAAAA,GAGA,QAAAC,GAAAD,GACA,sBAAAA,GAGA,QAAAE,GAAAF,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAG,GAAAH,GACA,gBAAAA,EA/QAnE,EAAAD,QAAAgE,EAGAA,iBAEAA,EAAA7C,UAAA8C,QAAAF,OACAC,EAAA7C,UAAA+C,cAAAH,OAIAC,EAAAQ,oBAAA,GAIAR,EAAA7C,UAAAsD,gBAAA,SAAAC,GACA,IAAAL,EAAAK,IAAA,EAAAA,GAAAC,MAAAD,GACA,KAAAE,WAAA,8BAEA,OADA/D,MAAAqD,cAAAQ,EACA7D,MAGAmD,EAAA7C,UAAA0B,KAAA,SAAAC,GACA,GAAA+B,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,CAMA,IAJArE,KAAAoD,UACApD,KAAAoD,YAGA,UAAAnB,KACAjC,KAAAoD,QAAAkB,OACAb,EAAAzD,KAAAoD,QAAAkB,SAAAtE,KAAAoD,QAAAkB,MAAA5B,QAAA,CAEA,GADAsB,EAAAO,UAAA,GACAP,YAAAQ,OACA,KAAAR,EAEA,MAAAD,WAAA,wCAMA,GAFAE,EAAAjE,KAAAoD,QAAAnB,GAEAyB,EAAAO,GACA,QAEA,IAAAX,EAAAW,GACA,OAAAM,UAAA7B,QAEA,OACAuB,EAAA1E,KAAAS,KACA,MACA,QACAiE,EAAA1E,KAAAS,KAAAuE,UAAA,GACA,MACA,QACAN,EAAA1E,KAAAS,KAAAuE,UAAA,GAAAA,UAAA,GACA,MAEA,SACAJ,EAAA3B,MAAAlC,UAAA4B,MAAA3C,KAAAgF,UAAA,GACAN,EAAAQ,MAAAzE,KAAAmE,OAEG,IAAAV,EAAAQ,GAIH,IAHAE,EAAA3B,MAAAlC,UAAA4B,MAAA3C,KAAAgF,UAAA,GACAF,EAAAJ,EAAA/B,QACAgC,EAAAG,EAAA3B,OACA0B,EAAA,EAAeF,EAAAE,EAASA,IACxBC,EAAAD,GAAAK,MAAAzE,KAAAmE,EAGA,WAGAhB,EAAA7C,UAAAoE,YAAA,SAAAzC,EAAA0C,GACA,GAAAnF,EAEA,KAAA8D,EAAAqB,GACA,KAAAZ,WAAA,8BA2CA,OAzCA/D,MAAAoD,UACApD,KAAAoD,YAIApD,KAAAoD,QAAAwB,aACA5E,KAAAgC,KAAA,cAAAC,EACAqB,EAAAqB,YACAA,cAEA3E,KAAAoD,QAAAnB,GAGAwB,EAAAzD,KAAAoD,QAAAnB,IAEAjC,KAAAoD,QAAAnB,GAAA4C,KAAAF,GAGA3E,KAAAoD,QAAAnB,IAAAjC,KAAAoD,QAAAnB,GAAA0C,GANA3E,KAAAoD,QAAAnB,GAAA0C,EASAlB,EAAAzD,KAAAoD,QAAAnB,MAAAjC,KAAAoD,QAAAnB,GAAA6C,SAIAtF,EAHAkE,EAAA1D,KAAAqD,eAGAF,EAAAQ,oBAFA3D,KAAAqD,cAKA7D,KAAA,GAAAQ,KAAAoD,QAAAnB,GAAAS,OAAAlD,IACAQ,KAAAoD,QAAAnB,GAAA6C,QAAA,EACArD,QAAA6C,MAAA,mIAGAtE,KAAAoD,QAAAnB,GAAAS,QACA,kBAAAjB,SAAAsD,OAEAtD,QAAAsD,UAKA/E,MAGAmD,EAAA7C,UAAA0E,GAAA7B,EAAA7C,UAAAoE,YAEAvB,EAAA7C,UAAA2E,KAAA,SAAAhD,EAAA0C,GAMA,QAAAO,KACAlF,KAAAmF,eAAAlD,EAAAiD,GAEAE,IACAA,GAAA,EACAT,EAAAF,MAAAzE,KAAAuE,YAVA,IAAAjB,EAAAqB,GACA,KAAAZ,WAAA,8BAEA,IAAAqB,IAAA,CAcA,OAHAF,GAAAP,WACA3E,KAAAgF,GAAA/C,EAAAiD,GAEAlF,MAIAmD,EAAA7C,UAAA6E,eAAA,SAAAlD,EAAA0C,GACA,GAAAU,GAAAC,EAAA5C,EAAA0B,CAEA,KAAAd,EAAAqB,GACA,KAAAZ,WAAA,8BAEA,KAAA/D,KAAAoD,UAAApD,KAAAoD,QAAAnB,GACA,MAAAjC,KAMA,IAJAqF,EAAArF,KAAAoD,QAAAnB,GACAS,EAAA2C,EAAA3C,OACA4C,EAAA,GAEAD,IAAAV,GACArB,EAAA+B,EAAAV,WAAAU,EAAAV,mBACA3E,MAAAoD,QAAAnB,GACAjC,KAAAoD,QAAA+B,gBACAnF,KAAAgC,KAAA,iBAAAC,EAAA0C,OAEG,IAAAlB,EAAA4B,GAAA,CACH,IAAAjB,EAAA1B,EAAoB0B,KAAA,GACpB,GAAAiB,EAAAjB,KAAAO,GACAU,EAAAjB,GAAAO,UAAAU,EAAAjB,GAAAO,aAAA,CACAW,EAAAlB,CACA,OAIA,KAAAkB,EACA,MAAAtF,KAEA,KAAAqF,EAAA3C,QACA2C,EAAA3C,OAAA,QACA1C,MAAAoD,QAAAnB,IAEAoD,EAAAE,OAAAD,EAAA,GAGAtF,KAAAoD,QAAA+B,gBACAnF,KAAAgC,KAAA,iBAAAC,EAAA0C,GAGA,MAAA3E,OAGAmD,EAAA7C,UAAAkF,mBAAA,SAAAvD,GACA,GAAAwD,GAAApB,CAEA,KAAArE,KAAAoD,QACA,MAAApD,KAGA,KAAAA,KAAAoD,QAAA+B,eAKA,MAJA,KAAAZ,UAAA7B,OACA1C,KAAAoD,WACApD,KAAAoD,QAAAnB,UACAjC,MAAAoD,QAAAnB,GACAjC,IAIA,QAAAuE,UAAA7B,OAAA,CACA,IAAA+C,IAAAzF,MAAAoD,QACA,mBAAAqC,GACAzF,KAAAwF,mBAAAC,EAIA,OAFAzF,MAAAwF,mBAAA,kBACAxF,KAAAoD,WACApD,KAKA,GAFAqE,EAAArE,KAAAoD,QAAAnB,GAEAqB,EAAAe,GACArE,KAAAmF,eAAAlD,EAAAoC,OACG,IAAAA,EAEH,KAAAA,EAAA3B,QACA1C,KAAAmF,eAAAlD,EAAAoC,IAAA3B,OAAA,GAIA,cAFA1C,MAAAoD,QAAAnB,GAEAjC,MAGAmD,EAAA7C,UAAA+D,UAAA,SAAApC,GACA,GAAAyD,EAOA,OAHAA,GAHA1F,KAAAoD,SAAApD,KAAAoD,QAAAnB,GAEAqB,EAAAtD,KAAAoD,QAAAnB,KACAjC,KAAAoD,QAAAnB,IAEAjC,KAAAoD,QAAAnB,GAAAC,YAIAiB,EAAA7C,UAAAqF,cAAA,SAAA1D,GACA,GAAAjC,KAAAoD,QAAA,CACA,GAAAwC,GAAA5F,KAAAoD,QAAAnB,EAEA,IAAAqB,EAAAsC,GACA,QACA,IAAAA,EACA,MAAAA,GAAAlD,OAEA,UAGAS,EAAAwC,cAAA,SAAAE,EAAA5D,GACA,MAAA4D,GAAAF,cAAA1D,KJ4MM,SAAS7C,EAAQD,EAASH,GAE/B,YKteD,IAAAW,GAAAX,EAA0B,GAC1B8G,EAAA9G,EAAyB,EAEzBA,GAAO,GAEP,IAAAc,GAAA,WAaE,QAAAA,GAAYa,EAAaoF,GAb3B,GAAA/E,GAAAhB,IAa2B,UAAA+F,OAAA,GANlB/F,KAAAgG,QAAkB,QAEjBhG,KAAAiG,iBAKNjG,KAAKkG,OAAS,GAAIvG,GAAAC,YAAYe,GAG9BX,KAAKkG,OAAOlB,GAAG,SAAU,WAEvB,IAAK,GADDmB,GAAQ5F,OAAO6F,KAAKpF,EAAKiF,eACpB7B,EAAI,EAAGF,EAAMiC,EAAMzD,OAAYwB,EAAJE,EAASA,IAC3CpD,EAAKqF,IAAIrF,EAAKgF,SAAWM,KAAMH,EAAM/B,OAIrC2B,GACF/F,KAAKe,UAuHX,MA9IER,QAAAgG,eAAkBzG,EAAA,aLsfX0G,IKtfP,SAA4BC,GAC1B9G,EAAAC,YAAYsB,UAAYuF,GLwfnBC,YAAY,EACZC,cAAc,IK/dd7G,EAAAQ,UAAAS,QAAP,WACEf,KAAKkG,OAAOnF,WAGPjB,EAAAQ,UAAAsG,QAAP,SAAeC,EAAgBlG,EAAaY,EAAgBuF,GAA5D,GAAA9F,GAAAhB,IACE,OAD0C,UAAAuB,UAAgB,SAAAuF,UACnD,GAAIhH,GAAYiH,QAAQ,SAACC,EAASC,GAClCjG,EAAKkF,OAAOjD,cAmBfjC,EAAKkF,OAAOrD,MACVgE,GAEEA,OAAQA,EACRC,QAASA,EACTnG,IAAKA,EACLY,KAAMA,IAEP,SAACA,GACwB,KAAtBA,EAAK,GAAG2F,WACVD,EAAO1F,EAAK,IAEZyF,EAAQzF,KA9BZP,EAAKkF,OAAOjB,KAAK,OAAQ,WACvBjE,EAAKkF,OAAOrD,MACVgE,GAEEA,OAAQA,EACRC,QAASA,EACTnG,IAAKA,EACLY,KAAMA,IAEP,SAACA,GACwB,KAAtBA,EAAK,GAAG2F,WACVD,EAAO1F,EAAK,IAEZyF,EAAQzF,SAqBf4F,KAAK,SAAU9F,GAChB,MAAOA,GAAI,MAIRvB,EAAAQ,UAAA8G,IAAP,SAAWzG,EAAamG,GACtB,MADsB,UAAAA,UACf9G,KAAK4G,QAAQ,MAAOjG,KAASmG,GAASK,KAAK,SAAU9F,GAC1D,MAAOA,GAAIgG,QAIRvH,EAAAQ,UAAAgH,KAAP,SAAY3G,EAAaY,EAAWuF,GAClC,MADkC,UAAAA,UAC3B9G,KAAK4G,QAAQ,OAAQjG,EAAKY,EAAMuF,GAASK,KAAK,SAAU9F,GAC7D,MAAOA,GAAIgG,QAIRvH,EAAAQ,UAAA+F,IAAP,SAAW1F,EAAaY,EAAWuF,GACjC,MADiC,UAAAA,UAC1B9G,KAAK4G,QAAQ,MAAOjG,EAAKY,EAAMuF,GAASK,KAAK,SAAU9F,GAC5D,MAAOA,GAAIgG,QAIRvH,EAAAQ,UAAAR,UAAP,SAAca,EAAaY,EAAWuF,GACpC,MADoC,UAAAA,UAC7B9G,KAAK4G,QAAQ,SAAUjG,EAAKY,EAAMuF,GAASK,KAAK,SAAU9F,GAC/D,MAAOA,GAAIgG,QAIRvH,EAAAQ,UAAAiH,KAAP,SAAYjB,EAAckB,GAA1B,GAAAxG,GAAAhB,IAIE,OAJwB,UAAAwH,OAAA,GACQ,MAA5BxH,KAAKiG,cAAcK,KACrBtG,KAAKiG,cAAcK,GAAQ,GAEtBR,EAAA2B,WAAWjH,OAAO,SAAAkH,GACvB,GAAMC,GAAiB,SAAApG,GAAQ,MAAAmG,GAASE,KAAKrG,GA8B7C,OA7BiC,KAA7BP,EAAKiF,cAAcK,GAErBtF,EAAKqF,IAAIrF,EAAKgF,SAAWM,KAAMA,IAC5Ba,KAAK,SAAC9F,GACDmG,GACFE,EAASE,MACPC,UAAU,EACVC,QAAS,aACTvG,KAAMF,IAIVL,EAAKiF,cAAcK,KACnBtF,EAAKkF,OAAOlB,GAAGsB,EAAMqB,KAXzB3G,SAaS,SAAA+G,GAAO,MAAAL,GAASpD,MAAMyD,MAG3BP,GACFE,EAASE,MACPC,UAAU,EACVC,QAAS,iBAGb9G,EAAKiF,cAAcK,KACnBtF,EAAKkF,OAAOlB,GAAGsB,EAAMqB,IAIhB,WACL3G,EAAKiF,cAAcK,KACnBtF,EAAKkF,OAAOf,eAAemB,EAAMqB,GAEA,IAA7B3G,EAAKiF,cAAcK,IACrBtF,YAAYA,EAAKgF,SAAWM,KAAMA,QA1I5BxG,EAAAiH,QAA6B,kBAAZA,SAAyBA,QAAU7D,OA+IpEpD,IAhJaX,GAAAW,YAAWA,GL6nBlB,SAASV,EAAQD,EAASH,GMloBhC,YACA,IAAAgJ,GAAAhJ,EAAA,GACAiJ,EAAAjJ,EAAA,GACAkJ,EAAAlJ,EAAA,GAOAyI,EAAA,WAQA,QAAAA,GAAAU,GACAnI,KAAAoI,WAAA,EACAD,IACAnI,KAAAqI,WAAAF,GA8GA,MApGAV,GAAAnH,UAAAgI,KAAA,SAAAC,GACA,GAAAC,GAAA,GAAAf,EAGA,OAFAe,GAAAC,OAAAzI,KACAwI,EAAAD,WACAC,GAaAf,EAAAnH,UAAA6H,UAAA,SAAAO,EAAApE,EAAAqE,GACA,GAAAJ,GAAAvI,KAAAuI,SACAK,EAAAV,EAAAW,aAAAH,EAAApE,EAAAqE,EAEA,IADAC,EAAAE,IAAAP,IAAAhJ,KAAAqJ,EAAA5I,WAAAqI,WAAAO,IACAA,EAAAG,qBACAH,EAAAG,oBAAA,EACAH,EAAAI,iBACA,KAAAJ,GAAAK,cAGA,OAAAL,IASAnB,EAAAnH,UAAA4I,QAAA,SAAAtB,EAAAuB,GACA,GAAAnI,GAAAhB,IASA,IARAmJ,IACAnB,EAAAoB,KAAAC,IAAArB,EAAAoB,KAAAC,GAAAC,QAAAtB,EAAAoB,KAAAC,GAAAC,OAAAvC,QACAoC,EAAAnB,EAAAoB,KAAAC,GAAAC,OAAAvC,QAEAiB,EAAAoB,KAAArC,UACAoC,EAAAnB,EAAAoB,KAAArC,WAGAoC,EACA,SAAA3E,OAAA,wBAEA,WAAA2E,GAAA,SAAAnC,EAAAC,GACA,GAAAsC,GAAAvI,EAAAmH,UAAA,SAAAqB,GACA,GAAAD,EAKA,IACA3B,EAAA4B,GAEA,MAAAzB,GACAd,EAAAc,GACAwB,EAAAE,kBAUA7B,GAAA4B,IAEavC,EAAAD,MAGbS,EAAAnH,UAAA+H,WAAA,SAAAqB,GACA,MAAA1J,MAAAyI,OAAAN,UAAAuB,IAOAjC,EAAAnH,UAAA2H,EAAA0B,cAAA,WACA,MAAA3J,OAYAyH,EAAAjH,OAAA,SAAA2H,GACA,UAAAV,GAAAU,IAEAV,IAEAtI,GAAAsI,cNyoBM,SAASrI,EAAQD,EAASH,IO9wBhC,SAAAI,EAAAwK,GAAA,YACA,IAAAC,IACAC,WAAA,EACAC,YAAA,EACAC,QAAA,EACAC,QAAA,EACAC,QAAA,EACAhH,WAAA,EAEA/D,GAAAiK,KAAAS,QAAAM,cAAAN,QAAAO,gBAEA,IAEAC,IAFAR,QAAA1K,WAAAmL,UAAAnL,EACA0K,QAAAzK,WAAAkL,UAAAlL,EACAyK,QAAAD,SACAS,KAAAT,SAAAS,KAAAD,SAAAC,IACAlL,EAAAiK,KAAAiB,KPmxB8B9K,KAAKJ,EAASH,EAAoB,GAAGI,GAAU,WAAa,MAAOY,WAI3F,SAASZ,EAAQD,GQtyBvBC,EAAAD,QAAA,SAAAC,GAQA,MAPAA,GAAAmL,kBACAnL,EAAAoL,UAAA,aACApL,EAAAqL,SAEArL,EAAAsL,YACAtL,EAAAmL,gBAAA,GAEAnL,IR8yBM,SAASA,EAAQD,EAASH,GStzBhC,YACA,IAAAgJ,GAAAhJ,EAAA,GACA2L,EAAA3C,EAAAoB,KAAAuB,MACA,mBAAAA,GACAA,EAAAnC,WACArJ,EAAAwK,aAAAgB,EAAAnC,YAGA,kBAAAmC,UACAxL,EAAAwK,aAAAgB,SAAA,cAGAxL,EAAAwK,aAAAgB,EAAA,cAEAA,EAAAnC,WAAArJ,EAAAwK,cAIAxK,EAAAwK,aAAA,gBT8zBM,SAASvK,EAAQD,EAASH,GUh1BhC,YAGA,SAAA6J,GAAA+B,EAAAtG,EAAAqE,GACA,GAAAiC,GAAA,gBAAAA,GAAA,CACA,GAAAA,YAAAC,GAAAC,WACA,MAAAF,EAEA,sBAAAA,GAAAG,EAAAC,gBACA,MAAAJ,GAAAG,EAAAC,kBAGA,UAAAH,GAAAC,WAAAF,EAAAtG,EAAAqE,GAXA,GAAAkC,GAAA7L,EAAA,GACA+L,EAAA/L,EAAA,GAYAG,GAAA0J,gBVu1BM,SAASzJ,EAAQD,EAASH,GWr2BhC,YACA,IAAAe,GAAAC,WAAAD,WAAA,SAAAE,EAAAC,GAEA,QAAAC,KAAmBH,KAAAI,YAAAH,EADnB,OAAAP,KAAAQ,KAAAG,eAAAX,KAAAO,EAAAP,GAAAQ,EAAAR,GAEAO,GAAAK,UAAA,OAAAJ,EAAAK,OAAAC,OAAAN,IAAAC,EAAAG,UAAAJ,EAAAI,UAAA,GAAAH,KAEA8K,EAAAjM,EAAA,IACAkM,EAAAlM,EAAA,IACA+L,EAAA/L,EAAA,IACAmM,EAAAnM,EAAA,IAWA8L,EAAA,SAAApK,GAUA,QAAAoK,GAAAM,EAAA9G,EAAAqE,GAMA,OALAjI,EAAAnB,KAAAS,MACAA,KAAAiJ,eAAA,KACAjJ,KAAAgJ,iBAAA,EACAhJ,KAAA+I,oBAAA,EACA/I,KAAAqL,WAAA,EACA9G,UAAA7B,QACA,OACA1C,KAAAsL,YAAAH,EAAAI,KACA,MACA,QACA,IAAAH,EAAA,CACApL,KAAAsL,YAAAH,EAAAI,KACA,OAEA,mBAAAH,GAAA,CACAA,YAAAN,IACA9K,KAAAsL,YAAAF,EACApL,KAAAsL,YAAAxC,IAAA9I,QAGAA,KAAA+I,oBAAA,EACA/I,KAAAsL,YAAA,GAAAE,GAAAxL,KAAAoL,GAEA,OAEA,QACApL,KAAA+I,oBAAA,EACA/I,KAAAsL,YAAA,GAAAE,GAAAxL,KAAAoL,EAAA9G,EAAAqE,IA8EA,MAnHA5I,GAAA+K,EAAApK,GAoDAoK,EAAAtK,OAAA,SAAAoH,EAAAtD,EAAAqE,GACA,GAAAe,GAAA,GAAAoB,GAAAlD,EAAAtD,EAAAqE,EAEA,OADAe,GAAAX,oBAAA,EACAW,GASAoB,EAAAxK,UAAAsH,KAAA,SAAA4B,GACAxJ,KAAAqL,WACArL,KAAAyL,MAAAjC,IAUAsB,EAAAxK,UAAAgE,MAAA,SAAAyD,GACA/H,KAAAqL,YACArL,KAAAqL,WAAA,EACArL,KAAA0L,OAAA3D,KASA+C,EAAAxK,UAAAqI,SAAA,WACA3I,KAAAqL,YACArL,KAAAqL,WAAA,EACArL,KAAA2L,cAGAb,EAAAxK,UAAAmJ,YAAA,WACAzJ,KAAA4L,iBAGA5L,KAAAqL,WAAA,EACA3K,EAAAJ,UAAAmJ,YAAAlK,KAAAS,QAEA8K,EAAAxK,UAAAmL,MAAA,SAAAjC,GACAxJ,KAAAsL,YAAA1D,KAAA4B,IAEAsB,EAAAxK,UAAAoL,OAAA,SAAA3D,GACA/H,KAAAsL,YAAAhH,MAAAyD,GACA/H,KAAAyJ,eAEAqB,EAAAxK,UAAAqL,UAAA,WACA3L,KAAAsL,YAAA3C,WACA3I,KAAAyJ,eAEAqB,EAAAxK,UAAAyK,EAAAC,gBAAA,WACA,MAAAhL,OAEA8K,GACCI,EAAAW,aACD1M,GAAA2L,YAMA,IAAAU,GAAA,SAAA9K,GAEA,QAAA8K,GAAAM,EAAApD,EAAApE,EAAAqE,GACAjI,EAAAnB,KAAAS,MACAA,KAAA8L,SACA,IAAAlE,GACAmE,EAAA/L,IACAiL,GAAA3H,WAAAoF,GACAd,EAAAc,EAEAA,IACAqD,EAAArD,EACAd,EAAAc,EAAAd,KACAtD,EAAAoE,EAAApE,MACAqE,EAAAD,EAAAC,SACAsC,EAAA3H,WAAAyI,EAAAtC,cACAzJ,KAAA8I,IAAAiD,EAAAtC,YAAAuC,KAAAD,IAEAA,EAAAtC,YAAAzJ,KAAAyJ,YAAAuC,KAAAhM,OAEAA,KAAAiM,SAAAF,EACA/L,KAAAyL,MAAA7D,EACA5H,KAAA0L,OAAApH,EACAtE,KAAA2L,UAAAhD,EAiFA,MAvGA5I,GAAAyL,EAAA9K,GAwBA8K,EAAAlL,UAAAsH,KAAA,SAAA4B,GACA,IAAAxJ,KAAAqL,WAAArL,KAAAyL,MAAA,CACA,GAAAK,GAAA9L,KAAA8L,OACAA,GAAA/C,mBAGA/I,KAAAkM,gBAAAJ,EAAA9L,KAAAyL,MAAAjC,IACAxJ,KAAAyJ,cAHAzJ,KAAAmM,aAAAnM,KAAAyL,MAAAjC,KAOAgC,EAAAlL,UAAAgE,MAAA,SAAAyD,GACA,IAAA/H,KAAAqL,UAAA,CACA,GAAAS,GAAA9L,KAAA8L,OACA,IAAA9L,KAAA0L,OACAI,EAAA/C,oBAKA/I,KAAAkM,gBAAAJ,EAAA9L,KAAA0L,OAAA3D,GACA/H,KAAAyJ,gBALAzJ,KAAAmM,aAAAnM,KAAA0L,OAAA3D,GACA/H,KAAAyJ,mBAOA,KAAAqC,EAAA/C,mBAEA,KADA/I,MAAAyJ,cACA1B,CAGA+D,GAAA7C,eAAAlB,EACA+D,EAAA9C,iBAAA,EACAhJ,KAAAyJ,iBAIA+B,EAAAlL,UAAAqI,SAAA,WACA,IAAA3I,KAAAqL,UAAA,CACA,GAAAS,GAAA9L,KAAA8L,OACA9L,MAAA2L,UACAG,EAAA/C,oBAKA/I,KAAAkM,gBAAAJ,EAAA9L,KAAA2L,WACA3L,KAAAyJ,gBALAzJ,KAAAmM,aAAAnM,KAAA2L,WACA3L,KAAAyJ,eAQAzJ,KAAAyJ,gBAIA+B,EAAAlL,UAAA6L,aAAA,SAAAC,EAAA5C,GACA,IACA4C,EAAA7M,KAAAS,KAAAiM,SAAAzC,GAEA,MAAAzB,GAEA,KADA/H,MAAAyJ,cACA1B,IAGAyD,EAAAlL,UAAA4L,gBAAA,SAAAG,EAAAD,EAAA5C,GACA,IACA4C,EAAA7M,KAAAS,KAAAiM,SAAAzC,GAEA,MAAAzB,GAGA,MAFAsE,GAAApD,eAAAlB,EACAsE,EAAArD,iBAAA,GACA,EAEA,UAEAwC,EAAAlL,UAAAgM,aAAA,WACA,GAAAR,GAAA9L,KAAA8L,OACA9L,MAAAiM,SAAA,KACAjM,KAAA8L,QAAA,KACAA,EAAArC,eAEA+B,GACCV,IX42BK,SAAS1L,EAAQD,GYrmCvB,YACA,SAAAmE,GAAAiJ,GACA,wBAAAA,GAEApN,EAAAmE,cZ4mCM,SAASlE,EAAQD,EAASH,GahnChC,YACA,IAAAwN,GAAAxN,EAAA,IACAyN,EAAAzN,EAAA,IACAiM,EAAAjM,EAAA,IACA0N,EAAA1N,EAAA,IACA2N,EAAA3N,EAAA,IACA4N,EAAA5N,EAAA,IAaA6M,EAAA,WAKA,QAAAA,GAAApC,GAKAzJ,KAAA4L,gBAAA,EACAnC,IACAzJ,KAAAsM,aAAA7C,GAmHA,MA1GAoC,GAAAvL,UAAAmJ,YAAA,WACA,GACAoD,GADAC,GAAA,CAEA,KAAA9M,KAAA4L,eAAA,CAGA5L,KAAA4L,gBAAA,CACA,IAAAmB,GAAA/M,KAAAsM,EAAAS,EAAAT,aAAAU,EAAAD,EAAAC,cAEA,IADAhN,KAAAgN,eAAA,KACA/B,EAAA3H,WAAAgJ,GAAA,CACA,GAAAW,GAAAP,EAAAQ,SAAAZ,GAAA/M,KAAAS,KACAiN,KAAAN,EAAAQ,cACAL,GAAA,GACAD,SAAAhI,KAAA8H,EAAAQ,YAAAC,IAGA,GAAAZ,EAAA/J,QAAAuK,GAGA,IAFA,GAAAK,GAAA,GACAnJ,EAAA8I,EAAAtK,SACA2K,EAAAnJ,GAAA,CACA,GAAAoJ,GAAAN,EAAAK,EACA,IAAAZ,EAAAhJ,SAAA6J,GAAA,CACA,GAAAL,GAAAP,EAAAQ,SAAAI,EAAA7D,aAAAlK,KAAA+N,EACA,IAAAL,IAAAN,EAAAQ,YAAA,CACAL,GAAA,EACAD,OACA,IAAA9E,GAAA4E,EAAAQ,YAAAC,CACArF,aAAA6E,GAAAW,oBACAV,IAAAW,OAAAzF,EAAA8E,QAGAA,EAAAhI,KAAAkD,KAMA,GAAA+E,EACA,SAAAF,GAAAW,oBAAAV,KAqBAhB,EAAAvL,UAAAwI,IAAA,SAAA2E,GACA,GAAAA,OAAAzN,MAAAyN,IAAA5B,EAAA6B,MAAA,CAGA,GAAAJ,GAAAG,CACA,cAAAA,IACA,eACAH,EAAA,GAAAzB,GAAA4B,EACA,cACA,GAAAH,EAAA1B,gBAAA,kBAAA0B,GAAA7D,YACA,KAEAzJ,MAAA4L,eACA0B,EAAA7D,eAGAzJ,KAAAgN,iBAAAhN,KAAAgN,oBAAAnI,KAAAyI,EAEA,MACA,SACA,SAAA9I,OAAA,yBAAAiJ,EAAA,2BAEA,MAAAH,KAQAzB,EAAAvL,UAAAqN,OAAA,SAAApE,GAEA,SAAAA,OAAAvJ,MAAAuJ,IAAAsC,EAAA6B,MAAA,CAGA,GAAAzH,GAAAjG,KAAAgN,cACA,IAAA/G,EAAA,CACA,GAAA2H,GAAA3H,EAAA4H,QAAAtE,EACA,MAAAqE,GACA3H,EAAAV,OAAAqI,EAAA,MAIA/B,EAAA6B,MAAA,SAAAnC,GAEA,MADAA,GAAAK,gBAAA,EACAL,GACK,GAAAM,IACLA,IAEA1M,GAAA0M,gBbunCM,SAASzM,EAAQD,Gc3wCvB,YACAA,GAAAsD,QAAAD,MAAAC,SAAA,SAAA8J,GAAkD,MAAAA,IAAA,gBAAAA,GAAA7J,SdkxC5C,SAAStD,EAAQD,GenxCvB,YACA,SAAAsE,GAAA8I,GACA,aAAAA,GAAA,gBAAAA,GAEApN,EAAAsE,Yf0xCM,SAASrE,EAAQD,EAASH,GgB9xChC,YAGA,SAAA8O,KACA,IACA,MAAAC,GAAAtJ,MAAAzE,KAAAuE,WAEA,MAAA6I,GAEA,MADAT,GAAAQ,YAAAC,IACAT,EAAAQ,aAGA,QAAAD,GAAAd,GAEA,MADA2B,GAAA3B,EACA0B,EAbA,GACAC,GADApB,EAAA3N,EAAA,GAeAG,GAAA+N,YhBsyCM,SAAS9N,EAAQD,GiBtzCvB,YAEAA,GAAAgO,aAAuBC,OjB6zCjB,SAAShO,EAAQD,GkB/zCvB,YACA,IAAAY,GAAAC,WAAAD,WAAA,SAAAE,EAAAC,GAEA,QAAAC,KAAmBH,KAAAI,YAAAH,EADnB,OAAAP,KAAAQ,KAAAG,eAAAX,KAAAO,EAAAP,GAAAQ,EAAAR,GAEAO,GAAAK,UAAA,OAAAJ,EAAAK,OAAAC,OAAAN,IAAAC,EAAAG,UAAAJ,EAAAI,UAAA,GAAAH,KAMAoN,EAAA,SAAA7M,GAEA,QAAA6M,GAAAV,GACAnM,EAAAnB,KAAAS,MACAA,KAAA6M,SACA7M,KAAAgO,KAAA,sBACAhO,KAAA8H,QAAA+E,IAAAnK,OAAA,4CAAAmK,EAAAoB,IAAA,SAAAlG,EAAA3D,GAA4H,MAAAA,GAAA,OAAA2D,EAAAmG,aAA4CC,KAAA,SAExK,MAPApO,GAAAwN,EAAA7M,GAOA6M,GACC/I,MACDrF,GAAAoO,uBlBs0CM,SAASnO,EAAQD,EAASH,GmB11ChC,YACA,IAAAgJ,GAAAhJ,EAAA,GACA2L,EAAA3C,EAAAoB,KAAAuB,MACAxL,GAAA6L,eAAA,kBAAAL,IAAA,kBAAAA,UACAA,SAAA,kCnBi2CM,SAASvL,EAAQD,GoBr2CvB,YACAA,GAAAoM,OACAK,gBAAA,EACAhE,KAAA,SAAA4B,KACAlF,MAAA,SAAAyD,GAA2B,KAAAA,IAC3BY,SAAA,epB62CM,SAASvJ,EAAQD,EAASH,GqBl3ChC,YACA,IAAA8G,GAAA9G,EAAA,GACAoP,EAAApP,EAAA,GACA8G,GAAA2B,WAAA4G,UAAAD,EAAAC,WrBy3CM,SAASjP,EAAQD,EAASH,GsB53ChC,YACA,IAAAsP,GAAAtP,EAAA,GACAG,GAAAkP,UAAAC,EAAAC,oBAAA/N,QtBm4CM,SAASpB,EAAQD,EAASH,GuBr4ChC,YAUA,SAAAwP,GAAAC,GACA,QAAAA,GAAA,kBAAAA,GAAA/J,aAAA,kBAAA+J,GAAAtJ,eAEA,QAAAuJ,GAAAD,GACA,QAAAA,GAAA,kBAAAA,GAAAzJ,IAAA,kBAAAyJ,GAAAE,IAEA,QAAAC,GAAAH,GACA,QAAAA,GAAA,sBAAAA,EAAAP,WAEA,QAAAW,GAAAJ,GACA,QAAAA,GAAA,4BAAAA,EAAAP,WAEA,QAAAY,GAAAL,GACA,QAAAA,GAAA,kBAAAA,GAAAtN,kBAAA,kBAAAsN,GAAAM,oBAtBA,GAAAhP,GAAAC,WAAAD,WAAA,SAAAE,EAAAC,GAEA,QAAAC,KAAmBH,KAAAI,YAAAH,EADnB,OAAAP,KAAAQ,KAAAG,eAAAX,KAAAO,EAAAP,GAAAQ,EAAAR,GAEAO,GAAAK,UAAA,OAAAJ,EAAAK,OAAAC,OAAAN,IAAAC,EAAAG,UAAAJ,EAAAI,UAAA,GAAAH,KAEA2F,EAAA9G,EAAA,GACA0N,EAAA1N,EAAA,IACA2N,EAAA3N,EAAA,IACAkM,EAAAlM,EAAA,IAqBAuP,EAAA,SAAA7N,GAEA,QAAA6N,GAAAE,EAAAO,EAAAC,GACAvO,EAAAnB,KAAAS,MACAA,KAAAyO,YACAzO,KAAAgP,YACAhP,KAAAiP,WAsDA,MA3DAlP,GAAAwO,EAAA7N,GAgBA6N,EAAA/N,OAAA,SAAAiO,EAAAO,EAAAC,GACA,UAAAV,GAAAE,EAAAO,EAAAC,IAEAV,EAAAW,kBAAA,SAAAT,EAAAO,EAAA/K,EAAAyF,GACA,GAAAD,EACA,IAAAmF,EAAAH,IAAAI,EAAAJ,GACA,OAAArK,GAAA,EAAAF,EAAAuK,EAAA/L,OAAmDwB,EAAAE,EAASA,IAC5DmK,EAAAW,kBAAAT,EAAArK,GAAA4K,EAAA/K,EAAAyF,OAGAoF,GAAAL,IACAA,EAAAtN,iBAAA6N,EAAA/K,GACAwF,EAAA,WAAuC,MAAAgF,GAAAM,oBAAAC,EAAA/K,KAEvCyK,EAAAD,IACAA,EAAAzJ,GAAAgK,EAAA/K,GACAwF,EAAA,WAAuC,MAAAgF,GAAAE,IAAAK,EAAA/K,KAEvCuK,EAAAC,KACAA,EAAA/J,YAAAsK,EAAA/K,GACAwF,EAAA,WAAuC,MAAAgF,GAAAtJ,eAAA6J,EAAA/K,IAEvCyF,GAAAZ,IAAA,GAAAoC,GAAAW,aAAApC,KAEA8E,EAAAjO,UAAA+H,WAAA,SAAAqB,GACA,GAAA+E,GAAAzO,KAAAyO,UACAO,EAAAhP,KAAAgP,UACAC,EAAAjP,KAAAiP,SACAhL,EAAAgL,EAAA,WAEA,OADA9K,MACAgL,EAAA,EAA4BA,EAAA5K,UAAA7B,OAAuByM,IACnDhL,EAAAgL,EAAA,GAAA5K,UAAA4K,EAEA,IAAAC,GAAA1C,EAAAQ,SAAA+B,GAAAxK,MAAA,OAAAN,EACAiL,KAAAzC,EAAAQ,YACAzD,EAAApF,MAAAqI,EAAAQ,YAAAC,GAGA1D,EAAA9B,KAAAwH,IAES,SAAAhC,GAAiB,MAAA1D,GAAA9B,KAAAwF,GAC1BmB,GAAAW,kBAAAT,EAAAO,EAAA/K,EAAAyF,IAEA6E,GACCzI,EAAA2B,WACDtI,GAAAoP","file":"wsabi-client.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar socket_1 = __webpack_require__(1);\r\n\texports.WsabiSocket = socket_1.WsabiSocket;\r\n\tvar client_1 = __webpack_require__(3);\r\n\texports.WsabiClient = client_1.WsabiClient;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar events_1 = __webpack_require__(2);\r\n\tvar WsabiSocket = (function (_super) {\r\n\t    __extends(WsabiSocket, _super);\r\n\t    function WsabiSocket(url) {\r\n\t        _super.call(this);\r\n\t        this.url = url;\r\n\t        this.messageId = 0;\r\n\t        this.waiting = {};\r\n\t        this.reconnecting = false;\r\n\t    }\r\n\t    WsabiSocket.prototype.connect = function () {\r\n\t        var _this = this;\r\n\t        this._socket = new WsabiSocket.WebSocket(this.url + \"/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0\");\r\n\t        this._socket.addEventListener(\"open\", function () {\r\n\t            _this.ping();\r\n\t        });\r\n\t        this._socket.addEventListener(\"message\", function (res) { return _this._handleSocketMessage(res.data); });\r\n\t        this._socket.addEventListener(\"close\", function (res) {\r\n\t            _this.reconnecting = true;\r\n\t            setTimeout(function () {\r\n\t                _this.connect();\r\n\t            }, 10000);\r\n\t        });\r\n\t        this._socket.addEventListener(\"error\", function (res) {\r\n\t            console.log(\"ERROR:\", res);\r\n\t        });\r\n\t    };\r\n\t    WsabiSocket.prototype.close = function () {\r\n\t        this._socket.close();\r\n\t    };\r\n\t    WsabiSocket.prototype._handleSocketMessage = function (res) {\r\n\t        var match = WsabiSocket.messageRegex.exec(res);\r\n\t        switch (parseInt(match[1])) {\r\n\t            case 0:\r\n\t                if (this.reconnecting) {\r\n\t                    this.reconnecting = false;\r\n\t                    this.emit(\"reopen\");\r\n\t                }\r\n\t                this.emit(\"open\");\r\n\t                break;\r\n\t            case 1:\r\n\t                this.close();\r\n\t                break;\r\n\t            case 3:\r\n\t                this.emit(\"pong\");\r\n\t                break;\r\n\t            case 4:\r\n\t                var type = parseInt(match[2][0]);\r\n\t                var id = parseInt(match[2].slice(1));\r\n\t                var data = void 0;\r\n\t                try {\r\n\t                    data = JSON.parse(match[3]);\r\n\t                }\r\n\t                catch (_) {\r\n\t                    data = match[3];\r\n\t                }\r\n\t                this._handleMessagePacket(type, id, data);\r\n\t                break;\r\n\t            default:\r\n\t                console.warn(\"Unsupported packet id\", match[1]);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype._handleMessagePacket = function (type, id, data) {\r\n\t        switch (type) {\r\n\t            case 2:\r\n\t                if (Array.isArray(data) && data.length == 2) {\r\n\t                    this.emit(data[0], data[1]);\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"message\", data);\r\n\t                }\r\n\t                break;\r\n\t            case 3:\r\n\t                if (this.waiting[id] != null) {\r\n\t                    this.waiting[id].call(this, data);\r\n\t                    delete this.waiting[id];\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"response\", {\r\n\t                        id: id,\r\n\t                        data: data\r\n\t                    });\r\n\t                }\r\n\t                break;\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.ping = function () {\r\n\t        var _this = this;\r\n\t        if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n\t            this._socket.send(\"2\");\r\n\t            setTimeout(function () {\r\n\t                _this.ping();\r\n\t            }, 50000);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.send = function (data, callback) {\r\n\t        var id = ++this.messageId;\r\n\t        if (callback != null) {\r\n\t            this.wait(id, callback);\r\n\t        }\r\n\t        this._socket.send((\"42\" + id) + JSON.stringify(data));\r\n\t    };\r\n\t    WsabiSocket.prototype.wait = function (id, callback) {\r\n\t        this.waiting[id] = callback;\r\n\t    };\r\n\t    WsabiSocket.prototype.isConnected = function () {\r\n\t        return this._socket.readyState === this._socket.OPEN;\r\n\t    };\r\n\t    WsabiSocket.WebSocket = typeof (WebSocket) === \"function\" ? WebSocket : undefined;\r\n\t    WsabiSocket.messageRegex = /(\\d)(\\d*)(.*)/;\r\n\t    return WsabiSocket;\r\n\t}(events_1.EventEmitter));\r\n\texports.WsabiSocket = WsabiSocket;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar socket_1 = __webpack_require__(1);\r\n\tvar Observable_1 = __webpack_require__(4);\r\n\t__webpack_require__(19);\r\n\tvar WsabiClient = (function () {\r\n\t    function WsabiClient(url, autoConnect) {\r\n\t        var _this = this;\r\n\t        if (autoConnect === void 0) { autoConnect = true; }\r\n\t        this.liveUrl = \"/live\";\r\n\t        this.subscriptions = {};\r\n\t        this.socket = new socket_1.WsabiSocket(url);\r\n\t        // Resub to live events on reconnect.\r\n\t        this.socket.on(\"reopen\", function () {\r\n\t            var slugs = Object.keys(_this.subscriptions);\r\n\t            for (var i = 0, len = slugs.length; i < len; i++) {\r\n\t                _this.put(_this.liveUrl, { slug: slugs[i] });\r\n\t            }\r\n\t        });\r\n\t        if (autoConnect) {\r\n\t            this.connect();\r\n\t        }\r\n\t    }\r\n\t    Object.defineProperty(WsabiClient, \"WebSocket\", {\r\n\t        set: function (ws) {\r\n\t            socket_1.WsabiSocket.WebSocket = ws;\r\n\t        },\r\n\t        enumerable: true,\r\n\t        configurable: true\r\n\t    });\r\n\t    WsabiClient.prototype.connect = function () {\r\n\t        this.socket.connect();\r\n\t    };\r\n\t    WsabiClient.prototype.request = function (method, url, data, headers) {\r\n\t        var _this = this;\r\n\t        if (data === void 0) { data = {}; }\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return new WsabiClient.Promise(function (resolve, reject) {\r\n\t            if (!_this.socket.isConnected()) {\r\n\t                _this.socket.once(\"open\", function () {\r\n\t                    _this.socket.send([\r\n\t                        method,\r\n\t                        {\r\n\t                            method: method,\r\n\t                            headers: headers,\r\n\t                            url: url,\r\n\t                            data: data\r\n\t                        }\r\n\t                    ], function (data) {\r\n\t                        if (data[0].statusCode != 200) {\r\n\t                            reject(data[0]);\r\n\t                        }\r\n\t                        else {\r\n\t                            resolve(data);\r\n\t                        }\r\n\t                    });\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                _this.socket.send([\r\n\t                    method,\r\n\t                    {\r\n\t                        method: method,\r\n\t                        headers: headers,\r\n\t                        url: url,\r\n\t                        data: data\r\n\t                    }\r\n\t                ], function (data) {\r\n\t                    if (data[0].statusCode != 200) {\r\n\t                        reject(data[0]);\r\n\t                    }\r\n\t                    else {\r\n\t                        resolve(data);\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        }).then(function (res) {\r\n\t            return res[0];\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.get = function (url, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"get\", url, {}, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.post = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"post\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.put = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"put\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.delete = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"delete\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.live = function (slug, listenConnect) {\r\n\t        var _this = this;\r\n\t        if (listenConnect === void 0) { listenConnect = false; }\r\n\t        if (this.subscriptions[slug] == null) {\r\n\t            this.subscriptions[slug] = 0;\r\n\t        }\r\n\t        return Observable_1.Observable.create(function (observer) {\r\n\t            var updateCallback = function (data) { return observer.next(data); };\r\n\t            if (_this.subscriptions[slug] === 0) {\r\n\t                // Not yet subscribed\r\n\t                _this.put(_this.liveUrl, { slug: slug })\r\n\t                    .then(function (res) {\r\n\t                    if (listenConnect) {\r\n\t                        observer.next({\r\n\t                            isClient: true,\r\n\t                            message: \"subscribed\",\r\n\t                            data: res\r\n\t                        });\r\n\t                    }\r\n\t                    _this.subscriptions[slug]++;\r\n\t                    _this.socket.on(slug, updateCallback);\r\n\t                })\r\n\t                    .catch(function (err) { return observer.error(err); });\r\n\t            }\r\n\t            else {\r\n\t                // Already subscribed, just listen for the event.\r\n\t                if (listenConnect) {\r\n\t                    observer.next({\r\n\t                        isClient: true,\r\n\t                        message: \"resubscribed\"\r\n\t                    });\r\n\t                }\r\n\t                _this.subscriptions[slug]++;\r\n\t                _this.socket.on(slug, updateCallback);\r\n\t            }\r\n\t            // Cleanup listener and delete subscription if last listener on unsub.\r\n\t            return function () {\r\n\t                _this.subscriptions[slug]--;\r\n\t                _this.socket.removeListener(slug, updateCallback);\r\n\t                if (_this.subscriptions[slug] === 0) {\r\n\t                    _this.delete(_this.liveUrl, { slug: slug });\r\n\t                }\r\n\t            };\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.Promise = typeof Promise === \"function\" ? Promise : undefined;\r\n\t    return WsabiClient;\r\n\t}());\r\n\texports.WsabiClient = WsabiClient;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(5);\n\tvar observable_1 = __webpack_require__(7);\n\tvar toSubscriber_1 = __webpack_require__(8);\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is  called when the Observable is\n\t     * initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or\n\t     * `complete` can be called to notify of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @return {Observable} a new observable with the Operator applied\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    /**\n\t     * Registers handlers for handling emitted values, error and completions from the observable, and\n\t     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n\t     * @method subscribe\n\t     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n\t     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n\t     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n\t     *  the error will be thrown as unhandled\n\t     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n\t     * @return {ISubscription} a subscription reference to the registered handlers\n\t     */\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var operator = this.operator;\n\t        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n\t        sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n\t        if (sink.syncErrorThrowable) {\n\t            sink.syncErrorThrowable = false;\n\t            if (sink.syncErrorThrown) {\n\t                throw sink.syncErrorValue;\n\t            }\n\t        }\n\t        return sink;\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @return {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, PromiseCtor) {\n\t        var _this = this;\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        return new PromiseCtor(function (resolve, reject) {\n\t            var subscription = _this.subscribe(function (value) {\n\t                if (subscription) {\n\t                    // if there is a subscription, then we can surmise\n\t                    // the next handling is asynchronous. Any errors thrown\n\t                    // need to be rejected explicitly and unsubscribe must be\n\t                    // called manually\n\t                    try {\n\t                        next(value);\n\t                    }\n\t                    catch (err) {\n\t                        reject(err);\n\t                        subscription.unsubscribe();\n\t                    }\n\t                }\n\t                else {\n\t                    // if there is NO subscription, then we're getting a nexted\n\t                    // value synchronously during subscription. We can just call it.\n\t                    // If it errors, Observable's `subscribe` imple will ensure the\n\t                    // unsubscription logic is called, then synchronously rethrow the error.\n\t                    // After that, Promise will trap the error and send it\n\t                    // down the rejection path.\n\t                    next(value);\n\t                }\n\t            }, reject, resolve);\n\t        });\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source.subscribe(subscriber);\n\t    };\n\t    /**\n\t     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     * @method Symbol.observable\n\t     * @return {Observable} this instance of the observable\n\t     */\n\t    Observable.prototype[observable_1.$$observable] = function () {\n\t        return this;\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * Creates a new cold Observable by calling the Observable constructor\n\t     * @static true\n\t     * @owner Observable\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @return {Observable} a new cold observable\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t}());\n\texports.Observable = Observable;\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module, global) {\"use strict\";\n\tvar objectTypes = {\n\t    'boolean': false,\n\t    'function': true,\n\t    'object': true,\n\t    'number': false,\n\t    'string': false,\n\t    'undefined': false\n\t};\n\texports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\t/* tslint:disable:no-unused-variable */\n\tvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\tvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\tvar freeGlobal = objectTypes[typeof global] && global;\n\tif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n\t    exports.root = freeGlobal;\n\t}\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(5);\n\tvar Symbol = root_1.root.Symbol;\n\tif (typeof Symbol === 'function') {\n\t    if (Symbol.observable) {\n\t        exports.$$observable = Symbol.observable;\n\t    }\n\t    else {\n\t        if (typeof Symbol.for === 'function') {\n\t            exports.$$observable = Symbol.for('observable');\n\t        }\n\t        else {\n\t            exports.$$observable = Symbol('observable');\n\t        }\n\t        Symbol.observable = exports.$$observable;\n\t    }\n\t}\n\telse {\n\t    exports.$$observable = '@@observable';\n\t}\n\t//# sourceMappingURL=observable.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Subscriber_1 = __webpack_require__(9);\n\tvar rxSubscriber_1 = __webpack_require__(17);\n\tfunction toSubscriber(nextOrObserver, error, complete) {\n\t    if (nextOrObserver && typeof nextOrObserver === 'object') {\n\t        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n\t            return nextOrObserver;\n\t        }\n\t        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n\t            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n\t        }\n\t    }\n\t    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n\t}\n\texports.toSubscriber = toSubscriber;\n\t//# sourceMappingURL=toSubscriber.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar isFunction_1 = __webpack_require__(10);\n\tvar Subscription_1 = __webpack_require__(11);\n\tvar rxSubscriber_1 = __webpack_require__(17);\n\tvar Observer_1 = __webpack_require__(18);\n\t/**\n\t * Implements the {@link Observer} interface and extends the\n\t * {@link Subscription} class. While the {@link Observer} is the public API for\n\t * consuming the values of an {@link Observable}, all Observers get converted to\n\t * a Subscriber, in order to provide Subscription-like capabilities such as\n\t * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n\t * implementing operators, but it is rarely used as a public API.\n\t *\n\t * @class Subscriber<T>\n\t */\n\tvar Subscriber = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    /**\n\t     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n\t     * defined Observer or a `next` callback function.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     */\n\t    function Subscriber(destinationOrNext, error, complete) {\n\t        _super.call(this);\n\t        this.syncErrorValue = null;\n\t        this.syncErrorThrown = false;\n\t        this.syncErrorThrowable = false;\n\t        this.isStopped = false;\n\t        switch (arguments.length) {\n\t            case 0:\n\t                this.destination = Observer_1.empty;\n\t                break;\n\t            case 1:\n\t                if (!destinationOrNext) {\n\t                    this.destination = Observer_1.empty;\n\t                    break;\n\t                }\n\t                if (typeof destinationOrNext === 'object') {\n\t                    if (destinationOrNext instanceof Subscriber) {\n\t                        this.destination = destinationOrNext;\n\t                        this.destination.add(this);\n\t                    }\n\t                    else {\n\t                        this.syncErrorThrowable = true;\n\t                        this.destination = new SafeSubscriber(this, destinationOrNext);\n\t                    }\n\t                    break;\n\t                }\n\t            default:\n\t                this.syncErrorThrowable = true;\n\t                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n\t                break;\n\t        }\n\t    }\n\t    /**\n\t     * A static factory for a Subscriber, given a (potentially partial) definition\n\t     * of an Observer.\n\t     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n\t     * @param {function(e: ?any): void} [error] The `error` callback of an\n\t     * Observer.\n\t     * @param {function(): void} [complete] The `complete` callback of an\n\t     * Observer.\n\t     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n\t     * Observer represented by the given arguments.\n\t     */\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber(next, error, complete);\n\t        subscriber.syncErrorThrowable = false;\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `next` from\n\t     * the Observable, with a value. The Observable may call this method 0 or more\n\t     * times.\n\t     * @param {T} [value] The `next` value.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isStopped) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive notifications of type `error` from\n\t     * the Observable, with an attached {@link Error}. Notifies the Observer that\n\t     * the Observable has experienced an error condition.\n\t     * @param {any} [err] The `error` exception.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._error(err);\n\t        }\n\t    };\n\t    /**\n\t     * The {@link Observer} callback to receive a valueless notification of type\n\t     * `complete` from the Observable. Notifies the Observer that the Observable\n\t     * has finished sending push-based notifications.\n\t     * @return {void}\n\t     */\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            this.isStopped = true;\n\t            this._complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this.isUnsubscribed) {\n\t            return;\n\t        }\n\t        this.isStopped = true;\n\t        _super.prototype.unsubscribe.call(this);\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        this.destination.next(value);\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        this.destination.error(err);\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        this.destination.complete();\n\t        this.unsubscribe();\n\t    };\n\t    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n\t        return this;\n\t    };\n\t    return Subscriber;\n\t}(Subscription_1.Subscription));\n\texports.Subscriber = Subscriber;\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @ignore\n\t * @extends {Ignored}\n\t */\n\tvar SafeSubscriber = (function (_super) {\n\t    __extends(SafeSubscriber, _super);\n\t    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n\t        _super.call(this);\n\t        this._parent = _parent;\n\t        var next;\n\t        var context = this;\n\t        if (isFunction_1.isFunction(observerOrNext)) {\n\t            next = observerOrNext;\n\t        }\n\t        else if (observerOrNext) {\n\t            context = observerOrNext;\n\t            next = observerOrNext.next;\n\t            error = observerOrNext.error;\n\t            complete = observerOrNext.complete;\n\t            if (isFunction_1.isFunction(context.unsubscribe)) {\n\t                this.add(context.unsubscribe.bind(context));\n\t            }\n\t            context.unsubscribe = this.unsubscribe.bind(this);\n\t        }\n\t        this._context = context;\n\t        this._next = next;\n\t        this._error = error;\n\t        this._complete = complete;\n\t    }\n\t    SafeSubscriber.prototype.next = function (value) {\n\t        if (!this.isStopped && this._next) {\n\t            var _parent = this._parent;\n\t            if (!_parent.syncErrorThrowable) {\n\t                this.__tryOrUnsub(this._next, value);\n\t            }\n\t            else if (this.__tryOrSetError(_parent, this._next, value)) {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.error = function (err) {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._error) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._error, err);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else if (!_parent.syncErrorThrowable) {\n\t                this.unsubscribe();\n\t                throw err;\n\t            }\n\t            else {\n\t                _parent.syncErrorValue = err;\n\t                _parent.syncErrorThrown = true;\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.complete = function () {\n\t        if (!this.isStopped) {\n\t            var _parent = this._parent;\n\t            if (this._complete) {\n\t                if (!_parent.syncErrorThrowable) {\n\t                    this.__tryOrUnsub(this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t                else {\n\t                    this.__tryOrSetError(_parent, this._complete);\n\t                    this.unsubscribe();\n\t                }\n\t            }\n\t            else {\n\t                this.unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            this.unsubscribe();\n\t            throw err;\n\t        }\n\t    };\n\t    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n\t        try {\n\t            fn.call(this._context, value);\n\t        }\n\t        catch (err) {\n\t            parent.syncErrorValue = err;\n\t            parent.syncErrorThrown = true;\n\t            return true;\n\t        }\n\t        return false;\n\t    };\n\t    SafeSubscriber.prototype._unsubscribe = function () {\n\t        var _parent = this._parent;\n\t        this._context = null;\n\t        this._parent = null;\n\t        _parent.unsubscribe();\n\t    };\n\t    return SafeSubscriber;\n\t}(Subscriber));\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isFunction(x) {\n\t    return typeof x === 'function';\n\t}\n\texports.isFunction = isFunction;\n\t//# sourceMappingURL=isFunction.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar isArray_1 = __webpack_require__(12);\n\tvar isObject_1 = __webpack_require__(13);\n\tvar isFunction_1 = __webpack_require__(10);\n\tvar tryCatch_1 = __webpack_require__(14);\n\tvar errorObject_1 = __webpack_require__(15);\n\tvar UnsubscriptionError_1 = __webpack_require__(16);\n\t/**\n\t * Represents a disposable resource, such as the execution of an Observable. A\n\t * Subscription has one important method, `unsubscribe`, that takes no argument\n\t * and just disposes the resource held by the subscription.\n\t *\n\t * Additionally, subscriptions may be grouped together through the `add()`\n\t * method, which will attach a child Subscription to the current Subscription.\n\t * When a Subscription is unsubscribed, all its children (and its grandchildren)\n\t * will be unsubscribed as well.\n\t *\n\t * @class Subscription\n\t */\n\tvar Subscription = (function () {\n\t    /**\n\t     * @param {function(): void} [unsubscribe] A function describing how to\n\t     * perform the disposal of resources when the `unsubscribe` method is called.\n\t     */\n\t    function Subscription(unsubscribe) {\n\t        /**\n\t         * A flag to indicate whether this Subscription has already been unsubscribed.\n\t         * @type {boolean}\n\t         */\n\t        this.isUnsubscribed = false;\n\t        if (unsubscribe) {\n\t            this._unsubscribe = unsubscribe;\n\t        }\n\t    }\n\t    /**\n\t     * Disposes the resources held by the subscription. May, for instance, cancel\n\t     * an ongoing Observable execution or cancel any other type of work that\n\t     * started when the Subscription was created.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.unsubscribe = function () {\n\t        var hasErrors = false;\n\t        var errors;\n\t        if (this.isUnsubscribed) {\n\t            return;\n\t        }\n\t        this.isUnsubscribed = true;\n\t        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n\t        this._subscriptions = null;\n\t        if (isFunction_1.isFunction(_unsubscribe)) {\n\t            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n\t            if (trial === errorObject_1.errorObject) {\n\t                hasErrors = true;\n\t                (errors = errors || []).push(errorObject_1.errorObject.e);\n\t            }\n\t        }\n\t        if (isArray_1.isArray(_subscriptions)) {\n\t            var index = -1;\n\t            var len = _subscriptions.length;\n\t            while (++index < len) {\n\t                var sub = _subscriptions[index];\n\t                if (isObject_1.isObject(sub)) {\n\t                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n\t                    if (trial === errorObject_1.errorObject) {\n\t                        hasErrors = true;\n\t                        errors = errors || [];\n\t                        var err = errorObject_1.errorObject.e;\n\t                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n\t                            errors = errors.concat(err.errors);\n\t                        }\n\t                        else {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        if (hasErrors) {\n\t            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n\t        }\n\t    };\n\t    /**\n\t     * Adds a tear down to be called during the unsubscribe() of this\n\t     * Subscription.\n\t     *\n\t     * If the tear down being added is a subscription that is already\n\t     * unsubscribed, is the same reference `add` is being called on, or is\n\t     * `Subscription.EMPTY`, it will not be added.\n\t     *\n\t     * If this subscription is already in an `isUnsubscribed` state, the passed\n\t     * tear down logic will be executed immediately.\n\t     *\n\t     * @param {TeardownLogic} teardown The additional logic to execute on\n\t     * teardown.\n\t     * @return {Subscription} Returns the Subscription used or created to be\n\t     * added to the inner subscriptions list. This Subscription can be used with\n\t     * `remove()` to remove the passed teardown logic from the inner subscriptions\n\t     * list.\n\t     */\n\t    Subscription.prototype.add = function (teardown) {\n\t        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var sub = teardown;\n\t        switch (typeof teardown) {\n\t            case 'function':\n\t                sub = new Subscription(teardown);\n\t            case 'object':\n\t                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n\t                    break;\n\t                }\n\t                else if (this.isUnsubscribed) {\n\t                    sub.unsubscribe();\n\t                }\n\t                else {\n\t                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n\t        }\n\t        return sub;\n\t    };\n\t    /**\n\t     * Removes a Subscription from the internal list of subscriptions that will\n\t     * unsubscribe during the unsubscribe process of this Subscription.\n\t     * @param {Subscription} subscription The subscription to remove.\n\t     * @return {void}\n\t     */\n\t    Subscription.prototype.remove = function (subscription) {\n\t        // HACK: This might be redundant because of the logic in `add()`\n\t        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.isUnsubscribed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t}());\n\texports.Subscription = Subscription;\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n\t//# sourceMappingURL=isArray.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tfunction isObject(x) {\n\t    return x != null && typeof x === 'object';\n\t}\n\texports.isObject = isObject;\n\t//# sourceMappingURL=isObject.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar errorObject_1 = __webpack_require__(15);\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\texports.tryCatch = tryCatch;\n\t;\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t// typeof any so that it we don't have to cast when comparing a result to the error object\n\texports.errorObject = { e: {} };\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\t/**\n\t * An error thrown when one or more errors have occurred during the\n\t * `unsubscribe` of a {@link Subscription}.\n\t */\n\tvar UnsubscriptionError = (function (_super) {\n\t    __extends(UnsubscriptionError, _super);\n\t    function UnsubscriptionError(errors) {\n\t        _super.call(this);\n\t        this.errors = errors;\n\t        this.name = 'UnsubscriptionError';\n\t        this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n\t    }\n\t    return UnsubscriptionError;\n\t}(Error));\n\texports.UnsubscriptionError = UnsubscriptionError;\n\t//# sourceMappingURL=UnsubscriptionError.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar root_1 = __webpack_require__(5);\n\tvar Symbol = root_1.root.Symbol;\n\texports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n\t    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\texports.empty = {\n\t    isUnsubscribed: true,\n\t    next: function (value) { },\n\t    error: function (err) { throw err; },\n\t    complete: function () { }\n\t};\n\t//# sourceMappingURL=Observer.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar Observable_1 = __webpack_require__(4);\n\tvar fromEvent_1 = __webpack_require__(20);\n\tObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar FromEventObservable_1 = __webpack_require__(21);\n\texports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(4);\n\tvar tryCatch_1 = __webpack_require__(14);\n\tvar errorObject_1 = __webpack_require__(15);\n\tvar Subscription_1 = __webpack_require__(11);\n\tfunction isNodeStyleEventEmmitter(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n\t}\n\tfunction isJQueryStyleEventEmitter(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n\t}\n\tfunction isNodeList(sourceObj) {\n\t    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n\t}\n\tfunction isHTMLCollection(sourceObj) {\n\t    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n\t}\n\tfunction isEventTarget(sourceObj) {\n\t    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n\t}\n\t/**\n\t * We need this JSDoc comment for affecting ESDoc.\n\t * @extends {Ignored}\n\t * @hide true\n\t */\n\tvar FromEventObservable = (function (_super) {\n\t    __extends(FromEventObservable, _super);\n\t    function FromEventObservable(sourceObj, eventName, selector) {\n\t        _super.call(this);\n\t        this.sourceObj = sourceObj;\n\t        this.eventName = eventName;\n\t        this.selector = selector;\n\t    }\n\t    /**\n\t     * @param sourceObj\n\t     * @param eventName\n\t     * @param selector\n\t     * @return {FromEventObservable}\n\t     * @static true\n\t     * @name fromEvent\n\t     * @owner Observable\n\t     */\n\t    FromEventObservable.create = function (sourceObj, eventName, selector) {\n\t        return new FromEventObservable(sourceObj, eventName, selector);\n\t    };\n\t    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n\t        var unsubscribe;\n\t        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n\t            for (var i = 0, len = sourceObj.length; i < len; i++) {\n\t                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n\t            }\n\t        }\n\t        else if (isEventTarget(sourceObj)) {\n\t            sourceObj.addEventListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n\t        }\n\t        else if (isJQueryStyleEventEmitter(sourceObj)) {\n\t            sourceObj.on(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n\t        }\n\t        else if (isNodeStyleEventEmmitter(sourceObj)) {\n\t            sourceObj.addListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n\t        }\n\t        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n\t    };\n\t    FromEventObservable.prototype._subscribe = function (subscriber) {\n\t        var sourceObj = this.sourceObj;\n\t        var eventName = this.eventName;\n\t        var selector = this.selector;\n\t        var handler = selector ? function () {\n\t            var args = [];\n\t            for (var _i = 0; _i < arguments.length; _i++) {\n\t                args[_i - 0] = arguments[_i];\n\t            }\n\t            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n\t            if (result === errorObject_1.errorObject) {\n\t                subscriber.error(errorObject_1.errorObject.e);\n\t            }\n\t            else {\n\t                subscriber.next(result);\n\t            }\n\t        } : function (e) { return subscriber.next(e); };\n\t        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n\t    };\n\t    return FromEventObservable;\n\t}(Observable_1.Observable));\n\texports.FromEventObservable = FromEventObservable;\n\t//# sourceMappingURL=FromEventObservable.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wsabi-client.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c87ce24303abda85834c\n **/","import {WsabiSocket} from \"./src/socket\";\r\nimport {WsabiClient} from \"./src/client\";\r\n\r\nexport {WsabiSocket, WsabiClient};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/index.ts\n **/","import {EventEmitter} from \"events\";\r\n\r\nexport class WsabiSocket extends EventEmitter {\r\n  public static WebSocket = typeof(WebSocket) === \"function\" ? WebSocket : undefined;\r\n  private static messageRegex = /(\\d)(\\d*)(.*)/;\r\n\r\n  private _socket: WebSocket;\r\n  private messageId = 0;\r\n  private waiting: {\r\n    [key: string]: (data: any) => void;\r\n  } = {};\r\n  private reconnecting: boolean = false;\r\n\r\n  constructor(public url: string) {\r\n    super();\r\n  }\r\n\r\n  connect() {\r\n    this._socket = new WsabiSocket.WebSocket(`${this.url}/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0`);\r\n    this._socket.addEventListener(\"open\", () => {\r\n      this.ping();\r\n    });\r\n    this._socket.addEventListener(\"message\", (res) => this._handleSocketMessage(res.data));\r\n    this._socket.addEventListener(\"close\", (res) => {\r\n      this.reconnecting = true;\r\n      setTimeout(() => {\r\n        this.connect();\r\n      }, 10000);\r\n    });\r\n    this._socket.addEventListener(\"error\", (res) => {\r\n      console.log(\"ERROR:\", res);\r\n    });\r\n  }\r\n\r\n  close() {\r\n    this._socket.close();\r\n  }\r\n\r\n  private _handleSocketMessage(res: string) {\r\n    let match = WsabiSocket.messageRegex.exec(res);\r\n    switch (parseInt(match[1])) {\r\n      case 0:\r\n        if (this.reconnecting) {\r\n          this.reconnecting = false;\r\n          this.emit(\"reopen\");\r\n        }\r\n        this.emit(\"open\");\r\n        break;\r\n      case 1:\r\n        this.close();\r\n        break;\r\n      case 3:\r\n        this.emit(\"pong\");\r\n        break;\r\n      case 4:\r\n        let type = parseInt(match[2][0]);\r\n        let id = parseInt(match[2].slice(1));\r\n        let data;\r\n        try {\r\n          data = JSON.parse(match[3]);\r\n        } catch (_) {\r\n          data = match[3];\r\n        }\r\n\r\n        this._handleMessagePacket(type, id, data);\r\n        break;\r\n      default:\r\n        console.warn(\"Unsupported packet id\", match[1]);\r\n    }\r\n  }\r\n\r\n  private _handleMessagePacket(type: number, id: number, data: any) {\r\n    switch (type) {\r\n      case 2:\r\n        if (Array.isArray(data) && data.length == 2) {\r\n          this.emit(data[0], data[1]);\r\n        } else {\r\n          this.emit(\"message\", data);\r\n        }\r\n        break;\r\n      case 3:\r\n        if (this.waiting[id] != null) {\r\n          this.waiting[id].call(this, data);\r\n          delete this.waiting[id];\r\n        } else {\r\n          this.emit(\"response\", {\r\n            id: id,\r\n            data: data\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  private ping() {\r\n    if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n      this._socket.send(\"2\");\r\n      setTimeout(() => {\r\n        this.ping();\r\n      }, 50000);\r\n    }\r\n  }\r\n\r\n  public send(data: any, callback?: (data: any) => void) {\r\n    let id = ++this.messageId;\r\n    if (callback != null) {\r\n      this.wait(id, callback);\r\n    }\r\n\r\n    this._socket.send(`42${id}` + JSON.stringify(data));\r\n  }\r\n\r\n  public wait(id: number, callback?: (data: any) => void) {\r\n    this.waiting[id] = callback;\r\n  }\r\n  \r\n  public isConnected() {\r\n    return this._socket.readyState === this._socket.OPEN;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/src/socket.ts\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 2\n ** module chunks = 0 1\n **/","import {WsabiSocket} from \"./socket\";\r\nimport {Observable} from \"rxjs/Observable\";\r\n\r\nimport \"rxjs/add/observable/fromEvent\";\r\n\r\nexport class WsabiClient {\r\n  public static Promise = typeof Promise === \"function\" ? Promise : undefined;\r\n  public static set WebSocket(ws: any) {\r\n    WsabiSocket.WebSocket = ws;\r\n  }\r\n\r\n  public socket: WsabiSocket;\r\n  public liveUrl: string = \"/live\"\r\n\r\n  private subscriptions: {\r\n    [key: string]: number\r\n  } = {};\r\n\r\n  constructor(url: string, autoConnect: boolean = true) {\r\n    this.socket = new WsabiSocket(url);\r\n    \r\n    // Resub to live events on reconnect.\r\n    this.socket.on(\"reopen\", () => {\r\n      let slugs = Object.keys(this.subscriptions);\r\n      for (let i = 0, len = slugs.length; i < len; i++) {\r\n        this.put(this.liveUrl, { slug: slugs[i] });\r\n      }\r\n    })\r\n\r\n    if (autoConnect) {\r\n      this.connect();\r\n    }\r\n  }\r\n\r\n  public connect() {\r\n    this.socket.connect();\r\n  }\r\n\r\n  public request(method: string, url: string, data: any = {}, headers: any = {}) {\r\n    return new WsabiClient.Promise((resolve, reject) => {\r\n      if (!this.socket.isConnected()) {\r\n        this.socket.once(\"open\", () => {\r\n          this.socket.send([\r\n            method,\r\n            {\r\n              method: method,\r\n              headers: headers,\r\n              url: url,\r\n              data: data\r\n            }\r\n          ], (data) => {\r\n            if (data[0].statusCode != 200) {\r\n              reject(data[0]);\r\n            } else {\r\n              resolve(data);\r\n            }\r\n          });\r\n        })\r\n      } else {\r\n        this.socket.send([\r\n          method,\r\n          {\r\n            method: method,\r\n            headers: headers,\r\n            url: url,\r\n            data: data\r\n          }\r\n        ], (data) => {\r\n          if (data[0].statusCode != 200) {\r\n            reject(data[0]);\r\n          } else {\r\n            resolve(data);\r\n          }\r\n        });\r\n      }\r\n    }).then(function (res) {\r\n      return res[0];\r\n    });\r\n  }\r\n\r\n  public get(url: string, headers: any = {}) {\r\n    return this.request(\"get\", url, {}, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public post(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"post\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public put(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"put\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public delete(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"delete\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public live(slug: string, listenConnect = false): Observable<any> {\r\n    if (this.subscriptions[slug] == null) {\r\n      this.subscriptions[slug] = 0;\r\n    }\r\n    return Observable.create(observer => {\r\n      const updateCallback = data => observer.next(data);\r\n      if (this.subscriptions[slug] === 0) {\r\n        // Not yet subscribed\r\n        this.put(this.liveUrl, { slug: slug })\r\n          .then((res) => {\r\n            if (listenConnect) {\r\n              observer.next({\r\n                isClient: true,\r\n                message: \"subscribed\",\r\n                data: res\r\n              });\r\n            }\r\n            \r\n            this.subscriptions[slug]++;\r\n            this.socket.on(slug, updateCallback);\r\n          })\r\n          .catch(err => observer.error(err));\r\n      } else {\r\n        // Already subscribed, just listen for the event.\r\n        if (listenConnect) {\r\n          observer.next({\r\n            isClient: true,\r\n            message: \"resubscribed\"\r\n          });\r\n        }\r\n        this.subscriptions[slug]++;\r\n        this.socket.on(slug, updateCallback);\r\n      }\r\n      \r\n      // Cleanup listener and delete subscription if last listener on unsub.\r\n      return () => {\r\n        this.subscriptions[slug]--;\r\n        this.socket.removeListener(slug, updateCallback);\r\n        \r\n        if (this.subscriptions[slug] === 0) {\r\n          this.delete(this.liveUrl, { slug: slug })\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./ts/src/client.ts\n **/","\"use strict\";\nvar root_1 = require('./util/root');\nvar observable_1 = require('./symbol/observable');\nvar toSubscriber_1 = require('./util/toSubscriber');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * Registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     * @method subscribe\n     * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @return {ISubscription} a subscription reference to the registered handlers\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` imple will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observable.js\n ** module id = 4\n ** module chunks = 0 1\n **/","\"use strict\";\nvar objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n/* tslint:disable:no-unused-variable */\nvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\nvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/root.js\n ** module id = 5\n ** module chunks = 0 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 6\n ** module chunks = 0 1\n **/","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nif (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n        exports.$$observable = Symbol.observable;\n    }\n    else {\n        if (typeof Symbol.for === 'function') {\n            exports.$$observable = Symbol.for('observable');\n        }\n        else {\n            exports.$$observable = Symbol('observable');\n        }\n        Symbol.observable = exports.$$observable;\n    }\n}\nelse {\n    exports.$$observable = '@@observable';\n}\n//# sourceMappingURL=observable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/observable.js\n ** module id = 7\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver && typeof nextOrObserver === 'object') {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        else if (typeof nextOrObserver[rxSubscriber_1.$$rxSubscriber] === 'function') {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/toSubscriber.js\n ** module id = 8\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar Observer_1 = require('./Observer');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parent, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parent = _parent;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parent = this._parent;\n            if (!_parent.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parent, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._error) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parent.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parent.syncErrorValue = err;\n                _parent.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parent = this._parent;\n            if (this._complete) {\n                if (!_parent.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parent, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parent = this._parent;\n        this._context = null;\n        this._parent = null;\n        _parent.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscriber.js\n ** module id = 9\n ** module chunks = 0 1\n **/","\"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isFunction.js\n ** module id = 10\n ** module chunks = 0 1\n **/","\"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.isUnsubscribed = false;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                (errors = errors || []).push(errorObject_1.errorObject.e);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(err.errors);\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `isUnsubscribed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {\n            return;\n        }\n        var sub = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                sub = new Subscription(teardown);\n            case 'object':\n                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.isUnsubscribed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        return sub;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        // HACK: This might be redundant because of the logic in `add()`\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.isUnsubscribed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscription.js\n ** module id = 11\n ** module chunks = 0 1\n **/","\"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isArray.js\n ** module id = 12\n ** module chunks = 0 1\n **/","\"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isObject.js\n ** module id = 13\n ** module chunks = 0 1\n **/","\"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryCatch.js\n ** module id = 14\n ** module chunks = 0 1\n **/","\"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/errorObject.js\n ** module id = 15\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        this.name = 'UnsubscriptionError';\n        this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n') : '';\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/UnsubscriptionError.js\n ** module id = 16\n ** module chunks = 0 1\n **/","\"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/rxSubscriber.js\n ** module id = 17\n ** module chunks = 0 1\n **/","\"use strict\";\nexports.empty = {\n    isUnsubscribed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observer.js\n ** module id = 18\n ** module chunks = 0 1\n **/","\"use strict\";\nvar Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromEvent.js\n ** module id = 19\n ** module chunks = 0 1\n **/","\"use strict\";\nvar FromEventObservable_1 = require('./FromEventObservable');\nexports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromEvent.js\n ** module id = 20\n ** module chunks = 0 1\n **/","\"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nfunction isNodeStyleEventEmmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isNodeList(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object NodeList]';\n}\nfunction isHTMLCollection(sourceObj) {\n    return !!sourceObj && sourceObj.toString() === '[object HTMLCollection]';\n}\nfunction isEventTarget(sourceObj) {\n    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n    }\n    /**\n     * @param sourceObj\n     * @param eventName\n     * @param selector\n     * @return {FromEventObservable}\n     * @static true\n     * @name fromEvent\n     * @owner Observable\n     */\n    FromEventObservable.create = function (sourceObj, eventName, selector) {\n        return new FromEventObservable(sourceObj, eventName, selector);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n        var unsubscribe;\n        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n            }\n        }\n        else if (isEventTarget(sourceObj)) {\n            sourceObj.addEventListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n        }\n        else if (isJQueryStyleEventEmitter(sourceObj)) {\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n        }\n        else if (isNodeStyleEventEmmitter(sourceObj)) {\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var selector = this.selector;\n        var handler = selector ? function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(errorObject_1.errorObject.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n    };\n    return FromEventObservable;\n}(Observable_1.Observable));\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=FromEventObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/FromEventObservable.js\n ** module id = 21\n ** module chunks = 0 1\n **/"],"sourceRoot":""}