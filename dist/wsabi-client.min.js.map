{"version":3,"sources":["webpack:///wsabi-client.min.js","webpack:///webpack/bootstrap d4a3d0cd55581f0468da?6379","webpack:///./typescript/index.ts?1c8a","webpack:///./typescript/src/socket.ts?c3c9","webpack:///./~/events/events.js?7c71","webpack:///./typescript/src/client.ts?f96b","webpack:///./~/rxjs/Observable.js?4e06","webpack:///./~/rxjs/Subscriber.js?215e","webpack:///./~/rxjs/util/noop.js?7168","webpack:///./~/rxjs/util/throwError.js?94d4","webpack:///./~/rxjs/util/tryOrOnError.js?fac7","webpack:///./~/rxjs/Subscription.js?5c58","webpack:///./~/rxjs/symbol/rxSubscriber.js?112c","webpack:///./~/rxjs/util/SymbolShim.js?1fa6","webpack:///./~/rxjs/util/root.js?93c3","webpack:///(webpack)/buildin/module.js?c3c2","webpack:///./~/rxjs/add/observable/fromEvent.js?b3f9","webpack:///./~/rxjs/observable/fromEvent.js?3895","webpack:///./~/rxjs/util/tryCatch.js?7694","webpack:///./~/rxjs/util/errorObject.js?f49b"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","socket_1","WsabiSocket","client_1","WsabiClient","__extends","this","d","b","__","constructor","hasOwnProperty","prototype","Object","create","events_1","_super","WsabiSocket.constructor","WsabiSocket.connect","WsabiSocket.close","WsabiSocket._handleSocketMessage","WsabiSocket._handleMessagePacket","WsabiSocket.ping","WsabiSocket.send","WsabiSocket.wait","WsabiSocket.isConnected","EventEmitter","_events","_maxListeners","undefined","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","TypeError","emit","type","er","handler","len","args","i","listeners","error","length","arguments","Error","Array","slice","apply","addListener","listener","newListener","push","warned","console","trace","on","once","g","removeListener","fired","list","position","splice","removeAllListeners","key","ret","listenerCount","evlistener","emitter","Observable_1","WsabiClient.constructor","WsabiClient.connect","WsabiClient.request","res","WsabiClient.get","body","WsabiClient.post","WsabiClient.put","WsabiClient.delete","WsabiClient.live","Subscriber_1","root_1","SymbolShim_1","rxSubscriber_1","Observable","subscribe","_isScalar","_subscribe","lift","operator","observable","source","SymbolShim","observerOrNext","complete","subscriber","Subscriber","rxSubscriber","next","add","forEach","thisArg","PromiseCtor","root","Rx","config","Promise","nextHandler","nextHandlerFn","value","_a","promiseCallback","promiseCallbackFn","resolve","reject","noop_1","throwError_1","tryOrOnError_1","Subscription_1","destination","_isUnsubscribed","subscription","_subscription","defineProperty","get","isUnsubscribed","set","Boolean","enumerable","configurable","_next","tryOrOnError","noop","_error","throwError","_complete","sub","remove","unsubscribe","err","Subscription","e","target","tryCatcher","_unsubscribe","subscriptions","_subscriptions","index","EMPTY","subscriptionIndex","indexOf","empty","polyfillSymbol","Symbol","ensureSymbol","ensureIterator","ensureObservable","ensureFor","symbolForPolyfill","description","iterator","Set","Map","keys","getOwnPropertyNames","global","objectTypes","boolean","function","object","number","string","self","window","freeGlobal","nodeType","webpackPolyfill","deprecate","paths","children","fromEvent_1","fromEvent","FromEventObservable","tryCatch_1","errorObject_1","sourceObj","eventName","selector","setupSubscription","tag","toString","addEventListener","removeEventListener","off","result","tryCatch","errorObject","tryCatchTarget","fn"],"mappings":"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","file":"wsabi-client.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar socket_1 = __webpack_require__(1);\r\n\texports.WsabiSocket = socket_1.WsabiSocket;\r\n\tvar client_1 = __webpack_require__(3);\r\n\texports.WsabiClient = client_1.WsabiClient;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar events_1 = __webpack_require__(2);\r\n\tvar WsabiSocket = (function (_super) {\r\n\t    __extends(WsabiSocket, _super);\r\n\t    function WsabiSocket(url) {\r\n\t        _super.call(this);\r\n\t        this.url = url;\r\n\t        this.messageId = 0;\r\n\t        this.waiting = {};\r\n\t        this.reconnecting = false;\r\n\t    }\r\n\t    WsabiSocket.prototype.connect = function () {\r\n\t        var _this = this;\r\n\t        this._socket = new WsabiSocket.WebSocket(this.url + \"/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0\");\r\n\t        this._socket.addEventListener(\"open\", function () {\r\n\t            _this.ping();\r\n\t        });\r\n\t        this._socket.addEventListener(\"message\", function (res) { return _this._handleSocketMessage(res.data); });\r\n\t        this._socket.addEventListener(\"close\", function (res) {\r\n\t            _this.reconnecting = true;\r\n\t            setTimeout(function () {\r\n\t                _this.connect();\r\n\t            }, 10000);\r\n\t        });\r\n\t        this._socket.addEventListener(\"error\", function (res) {\r\n\t            console.log(\"ERROR:\", res);\r\n\t        });\r\n\t    };\r\n\t    WsabiSocket.prototype.close = function () {\r\n\t        this._socket.close();\r\n\t    };\r\n\t    WsabiSocket.prototype._handleSocketMessage = function (res) {\r\n\t        var match = WsabiSocket.messageRegex.exec(res);\r\n\t        switch (parseInt(match[1])) {\r\n\t            case 0:\r\n\t                if (this.reconnecting) {\r\n\t                    this.reconnecting = false;\r\n\t                    this.emit(\"reopen\");\r\n\t                }\r\n\t                this.emit(\"open\");\r\n\t                break;\r\n\t            case 1:\r\n\t                this.close();\r\n\t                break;\r\n\t            case 3:\r\n\t                this.emit(\"pong\");\r\n\t                break;\r\n\t            case 4:\r\n\t                var type = parseInt(match[2][0]);\r\n\t                var id = parseInt(match[2].slice(1));\r\n\t                var data;\r\n\t                try {\r\n\t                    data = JSON.parse(match[3]);\r\n\t                }\r\n\t                catch (_) {\r\n\t                    data = match[3];\r\n\t                }\r\n\t                this._handleMessagePacket(type, id, data);\r\n\t                break;\r\n\t            default:\r\n\t                console.warn(\"Unsupported packet id\", match[1]);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype._handleMessagePacket = function (type, id, data) {\r\n\t        switch (type) {\r\n\t            case 2:\r\n\t                if (Array.isArray(data) && data.length == 2) {\r\n\t                    this.emit(data[0], data[1]);\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"message\", data);\r\n\t                }\r\n\t                break;\r\n\t            case 3:\r\n\t                if (this.waiting[id] != null) {\r\n\t                    this.waiting[id].call(this, data);\r\n\t                    delete this.waiting[id];\r\n\t                }\r\n\t                else {\r\n\t                    this.emit(\"response\", {\r\n\t                        id: id,\r\n\t                        data: data\r\n\t                    });\r\n\t                }\r\n\t                break;\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.ping = function () {\r\n\t        var _this = this;\r\n\t        if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n\t            this._socket.send(\"2\");\r\n\t            setTimeout(function () {\r\n\t                _this.ping();\r\n\t            }, 50000);\r\n\t        }\r\n\t    };\r\n\t    WsabiSocket.prototype.send = function (data, callback) {\r\n\t        var id = ++this.messageId;\r\n\t        if (callback != null) {\r\n\t            this.wait(id, callback);\r\n\t        }\r\n\t        this._socket.send((\"42\" + id) + JSON.stringify(data));\r\n\t    };\r\n\t    WsabiSocket.prototype.wait = function (id, callback) {\r\n\t        this.waiting[id] = callback;\r\n\t    };\r\n\t    WsabiSocket.prototype.isConnected = function () {\r\n\t        return this._socket.readyState === this._socket.OPEN;\r\n\t    };\r\n\t    WsabiSocket.WebSocket = typeof (WebSocket) === \"function\" ? WebSocket : undefined;\r\n\t    WsabiSocket.messageRegex = /(\\d)(\\d*)(.*)/;\r\n\t    return WsabiSocket;\r\n\t})(events_1.EventEmitter);\r\n\texports.WsabiSocket = WsabiSocket;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar socket_1 = __webpack_require__(1);\r\n\tvar Observable_1 = __webpack_require__(4);\r\n\t__webpack_require__(14);\r\n\tvar WsabiClient = (function () {\r\n\t    function WsabiClient(url, autoConnect) {\r\n\t        var _this = this;\r\n\t        if (autoConnect === void 0) { autoConnect = true; }\r\n\t        this.liveUrl = \"/live\";\r\n\t        this.logging = true;\r\n\t        this.subscriptions = {};\r\n\t        this.socket = new socket_1.WsabiSocket(url);\r\n\t        this.socket.on(\"reopen\", function () {\r\n\t            var slugs = Object.keys(_this.subscriptions);\r\n\t            for (var i = 0, len = slugs.length; i < len; i++) {\r\n\t                _this.put(_this.liveUrl, { slug: slugs[i] });\r\n\t            }\r\n\t        });\r\n\t        if (autoConnect) {\r\n\t            this.connect();\r\n\t        }\r\n\t    }\r\n\t    WsabiClient.prototype.connect = function () {\r\n\t        this.socket.connect();\r\n\t    };\r\n\t    WsabiClient.prototype.request = function (method, url, data, headers) {\r\n\t        var _this = this;\r\n\t        if (data === void 0) { data = {}; }\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return new WsabiClient.Promise(function (resolve, reject) {\r\n\t            if (!_this.socket.isConnected()) {\r\n\t                _this.socket.once(\"open\", function () {\r\n\t                    _this.socket.send([\r\n\t                        method,\r\n\t                        {\r\n\t                            method: method,\r\n\t                            headers: headers,\r\n\t                            url: url,\r\n\t                            data: data\r\n\t                        }\r\n\t                    ], function (data) {\r\n\t                        if (data[0].statusCode != 200) {\r\n\t                            reject(data[0]);\r\n\t                        }\r\n\t                        else {\r\n\t                            resolve(data);\r\n\t                        }\r\n\t                    });\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                _this.socket.send([\r\n\t                    method,\r\n\t                    {\r\n\t                        method: method,\r\n\t                        headers: headers,\r\n\t                        url: url,\r\n\t                        data: data\r\n\t                    }\r\n\t                ], function (data) {\r\n\t                    if (data[0].statusCode != 200) {\r\n\t                        reject(data[0]);\r\n\t                    }\r\n\t                    else {\r\n\t                        resolve(data);\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        }).then(function (res) {\r\n\t            return res[0];\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.get = function (url, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"get\", url, {}, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.post = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"post\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.put = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"put\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.delete = function (url, data, headers) {\r\n\t        if (headers === void 0) { headers = {}; }\r\n\t        return this.request(\"delete\", url, data, headers).then(function (res) {\r\n\t            return res.body;\r\n\t        });\r\n\t    };\r\n\t    WsabiClient.prototype.live = function (slug) {\r\n\t        var _this = this;\r\n\t        if (!this.subscriptions.hasOwnProperty(slug)) {\r\n\t            this.subscriptions[slug] = Observable_1.Observable.fromEvent(this.socket, slug);\r\n\t            this.put(this.liveUrl, { slug: slug }).then(function (res) {\r\n\t                if (_this.logging) {\r\n\t                    console.log(\"[Wsabi]\", \"[\" + slug + \"]\", res.message || res);\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        return this.subscriptions[slug];\r\n\t    };\r\n\t    WsabiClient.Promise = typeof (Promise) === \"function\" ? Promise : undefined;\r\n\t    return WsabiClient;\r\n\t})();\r\n\texports.WsabiClient = WsabiClient;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Subscriber_1 = __webpack_require__(5);\n\tvar root_1 = __webpack_require__(12);\n\tvar SymbolShim_1 = __webpack_require__(11);\n\tvar rxSubscriber_1 = __webpack_require__(10);\n\t/**\n\t * A representation of any set of values over any amount of time. This the most basic building block\n\t * of RxJS.\n\t *\n\t * @class Observable<T>\n\t */\n\tvar Observable = (function () {\n\t    /**\n\t     * @constructor\n\t     * @param {Function} subscribe the function that is\n\t     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values\n\t     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify\n\t     * of a successful completion.\n\t     */\n\t    function Observable(subscribe) {\n\t        this._isScalar = false;\n\t        if (subscribe) {\n\t            this._subscribe = subscribe;\n\t        }\n\t    }\n\t    /**\n\t     * @method lift\n\t     * @param {Operator} operator the operator defining the operation to take on the observable\n\t     * @returns {Observable} a new observable with the Operator applied\n\t     * @description creates a new Observable, with this Observable as the source, and the passed\n\t     * operator defined as the new observable's operator.\n\t     */\n\t    Observable.prototype.lift = function (operator) {\n\t        var observable = new Observable();\n\t        observable.source = this;\n\t        observable.operator = operator;\n\t        return observable;\n\t    };\n\t    /**\n\t     * @method Symbol.observable\n\t     * @returns {Observable} this instance of the observable\n\t     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n\t     */\n\t    Observable.prototype[SymbolShim_1.SymbolShim.observable] = function () {\n\t        return this;\n\t    };\n\t    /**\n\t     * @method subscribe\n\t     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,\n\t     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n\t     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n\t     *  the error will be thrown as unhandled\n\t     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n\t     * @returns {Subscription} a subscription reference to the registered handlers\n\t     * @description registers handlers for handling emitted values, error and completions from the observable, and\n\t     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n\t     */\n\t    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n\t        var subscriber;\n\t        if (observerOrNext && typeof observerOrNext === 'object') {\n\t            if (observerOrNext instanceof Subscriber_1.Subscriber) {\n\t                subscriber = observerOrNext;\n\t            }\n\t            else if (observerOrNext[rxSubscriber_1.rxSubscriber]) {\n\t                subscriber = observerOrNext[rxSubscriber_1.rxSubscriber]();\n\t            }\n\t            else {\n\t                subscriber = new Subscriber_1.Subscriber(observerOrNext);\n\t            }\n\t        }\n\t        else {\n\t            var next = observerOrNext;\n\t            subscriber = Subscriber_1.Subscriber.create(next, error, complete);\n\t        }\n\t        subscriber.add(this._subscribe(subscriber));\n\t        return subscriber;\n\t    };\n\t    /**\n\t     * @method forEach\n\t     * @param {Function} next a handler for each value emitted by the observable\n\t     * @param {any} [thisArg] a `this` context for the `next` handler function\n\t     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n\t     * @returns {Promise} a promise that either resolves on observable completion or\n\t     *  rejects with the handled error\n\t     */\n\t    Observable.prototype.forEach = function (next, thisArg, PromiseCtor) {\n\t        if (!PromiseCtor) {\n\t            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n\t                PromiseCtor = root_1.root.Rx.config.Promise;\n\t            }\n\t            else if (root_1.root.Promise) {\n\t                PromiseCtor = root_1.root.Promise;\n\t            }\n\t        }\n\t        if (!PromiseCtor) {\n\t            throw new Error('no Promise impl found');\n\t        }\n\t        var nextHandler;\n\t        if (thisArg) {\n\t            nextHandler = function nextHandlerFn(value) {\n\t                var _a = nextHandlerFn, thisArg = _a.thisArg, next = _a.next;\n\t                return next.call(thisArg, value);\n\t            };\n\t            nextHandler.thisArg = thisArg;\n\t            nextHandler.next = next;\n\t        }\n\t        else {\n\t            nextHandler = next;\n\t        }\n\t        var promiseCallback = function promiseCallbackFn(resolve, reject) {\n\t            var _a = promiseCallbackFn, source = _a.source, nextHandler = _a.nextHandler;\n\t            source.subscribe(nextHandler, reject, resolve);\n\t        };\n\t        promiseCallback.source = this;\n\t        promiseCallback.nextHandler = nextHandler;\n\t        return new PromiseCtor(promiseCallback);\n\t    };\n\t    Observable.prototype._subscribe = function (subscriber) {\n\t        return this.source._subscribe(this.operator.call(subscriber));\n\t    };\n\t    // HACK: Since TypeScript inherits static properties too, we have to\n\t    // fight against TypeScript here so Subject can have a different static create signature\n\t    /**\n\t     * @static\n\t     * @method create\n\t     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n\t     * @returns {Observable} a new cold observable\n\t     * @description creates a new cold Observable by calling the Observable constructor\n\t     */\n\t    Observable.create = function (subscribe) {\n\t        return new Observable(subscribe);\n\t    };\n\t    return Observable;\n\t})();\n\texports.Observable = Observable;\n\t//# sourceMappingURL=Observable.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar noop_1 = __webpack_require__(6);\n\tvar throwError_1 = __webpack_require__(7);\n\tvar tryOrOnError_1 = __webpack_require__(8);\n\tvar Subscription_1 = __webpack_require__(9);\n\tvar rxSubscriber_1 = __webpack_require__(10);\n\tvar Subscriber = (function (_super) {\n\t    __extends(Subscriber, _super);\n\t    function Subscriber(destination) {\n\t        _super.call(this);\n\t        this.destination = destination;\n\t        this._isUnsubscribed = false;\n\t        if (!this.destination) {\n\t            return;\n\t        }\n\t        var subscription = destination._subscription;\n\t        if (subscription) {\n\t            this._subscription = subscription;\n\t        }\n\t        else if (destination instanceof Subscriber) {\n\t            this._subscription = destination;\n\t        }\n\t    }\n\t    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n\t        return this;\n\t    };\n\t    Object.defineProperty(Subscriber.prototype, \"isUnsubscribed\", {\n\t        get: function () {\n\t            var subscription = this._subscription;\n\t            if (subscription) {\n\t                // route to the shared Subscription if it exists\n\t                return this._isUnsubscribed || subscription.isUnsubscribed;\n\t            }\n\t            else {\n\t                return this._isUnsubscribed;\n\t            }\n\t        },\n\t        set: function (value) {\n\t            var subscription = this._subscription;\n\t            if (subscription) {\n\t                // route to the shared Subscription if it exists\n\t                subscription.isUnsubscribed = Boolean(value);\n\t            }\n\t            else {\n\t                this._isUnsubscribed = Boolean(value);\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Subscriber.create = function (next, error, complete) {\n\t        var subscriber = new Subscriber();\n\t        subscriber._next = (typeof next === 'function') && tryOrOnError_1.tryOrOnError(next) || noop_1.noop;\n\t        subscriber._error = (typeof error === 'function') && error || throwError_1.throwError;\n\t        subscriber._complete = (typeof complete === 'function') && complete || noop_1.noop;\n\t        return subscriber;\n\t    };\n\t    Subscriber.prototype.add = function (sub) {\n\t        // route add to the shared Subscription if it exists\n\t        var _subscription = this._subscription;\n\t        if (_subscription) {\n\t            _subscription.add(sub);\n\t        }\n\t        else {\n\t            _super.prototype.add.call(this, sub);\n\t        }\n\t    };\n\t    Subscriber.prototype.remove = function (sub) {\n\t        // route remove to the shared Subscription if it exists\n\t        if (this._subscription) {\n\t            this._subscription.remove(sub);\n\t        }\n\t        else {\n\t            _super.prototype.remove.call(this, sub);\n\t        }\n\t    };\n\t    Subscriber.prototype.unsubscribe = function () {\n\t        if (this._isUnsubscribed) {\n\t            return;\n\t        }\n\t        else if (this._subscription) {\n\t            this._isUnsubscribed = true;\n\t        }\n\t        else {\n\t            _super.prototype.unsubscribe.call(this);\n\t        }\n\t    };\n\t    Subscriber.prototype._next = function (value) {\n\t        var destination = this.destination;\n\t        if (destination.next) {\n\t            destination.next(value);\n\t        }\n\t    };\n\t    Subscriber.prototype._error = function (err) {\n\t        var destination = this.destination;\n\t        if (destination.error) {\n\t            destination.error(err);\n\t        }\n\t    };\n\t    Subscriber.prototype._complete = function () {\n\t        var destination = this.destination;\n\t        if (destination.complete) {\n\t            destination.complete();\n\t        }\n\t    };\n\t    Subscriber.prototype.next = function (value) {\n\t        if (!this.isUnsubscribed) {\n\t            this._next(value);\n\t        }\n\t    };\n\t    Subscriber.prototype.error = function (err) {\n\t        if (!this.isUnsubscribed) {\n\t            this._error(err);\n\t            this.unsubscribe();\n\t        }\n\t    };\n\t    Subscriber.prototype.complete = function () {\n\t        if (!this.isUnsubscribed) {\n\t            this._complete();\n\t            this.unsubscribe();\n\t        }\n\t    };\n\t    return Subscriber;\n\t})(Subscription_1.Subscription);\n\texports.Subscriber = Subscriber;\n\t//# sourceMappingURL=Subscriber.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/* tslint:disable:no-empty */\n\tfunction noop() { }\n\texports.noop = noop;\n\t//# sourceMappingURL=noop.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tfunction throwError(e) { throw e; }\n\texports.throwError = throwError;\n\t//# sourceMappingURL=throwError.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tfunction tryOrOnError(target) {\n\t    function tryCatcher() {\n\t        try {\n\t            tryCatcher.target.apply(this, arguments);\n\t        }\n\t        catch (e) {\n\t            this.error(e);\n\t        }\n\t    }\n\t    tryCatcher.target = target;\n\t    return tryCatcher;\n\t}\n\texports.tryOrOnError = tryOrOnError;\n\t//# sourceMappingURL=tryOrOnError.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar noop_1 = __webpack_require__(6);\n\tvar Subscription = (function () {\n\t    function Subscription(_unsubscribe) {\n\t        this.isUnsubscribed = false;\n\t        if (_unsubscribe) {\n\t            this._unsubscribe = _unsubscribe;\n\t        }\n\t    }\n\t    Subscription.prototype._unsubscribe = function () {\n\t        noop_1.noop();\n\t    };\n\t    Subscription.prototype.unsubscribe = function () {\n\t        if (this.isUnsubscribed) {\n\t            return;\n\t        }\n\t        this.isUnsubscribed = true;\n\t        var unsubscribe = this._unsubscribe;\n\t        var subscriptions = this._subscriptions;\n\t        this._subscriptions = void 0;\n\t        if (unsubscribe) {\n\t            unsubscribe.call(this);\n\t        }\n\t        if (subscriptions != null) {\n\t            var index = -1;\n\t            var len = subscriptions.length;\n\t            while (++index < len) {\n\t                subscriptions[index].unsubscribe();\n\t            }\n\t        }\n\t    };\n\t    Subscription.prototype.add = function (subscription) {\n\t        // return early if:\n\t        //  1. the subscription is null\n\t        //  2. we're attempting to add our this\n\t        //  3. we're attempting to add the static `empty` Subscription\n\t        if (!subscription || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var sub = subscription;\n\t        switch (typeof subscription) {\n\t            case 'function':\n\t                sub = new Subscription(subscription);\n\t            case 'object':\n\t                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n\t                    break;\n\t                }\n\t                else if (this.isUnsubscribed) {\n\t                    sub.unsubscribe();\n\t                }\n\t                else {\n\t                    var subscriptions = this._subscriptions || (this._subscriptions = []);\n\t                    subscriptions.push(sub);\n\t                }\n\t                break;\n\t            default:\n\t                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');\n\t        }\n\t    };\n\t    Subscription.prototype.remove = function (subscription) {\n\t        // return early if:\n\t        //  1. the subscription is null\n\t        //  2. we're attempting to remove ourthis\n\t        //  3. we're attempting to remove the static `empty` Subscription\n\t        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n\t            return;\n\t        }\n\t        var subscriptions = this._subscriptions;\n\t        if (subscriptions) {\n\t            var subscriptionIndex = subscriptions.indexOf(subscription);\n\t            if (subscriptionIndex !== -1) {\n\t                subscriptions.splice(subscriptionIndex, 1);\n\t            }\n\t        }\n\t    };\n\t    Subscription.EMPTY = (function (empty) {\n\t        empty.isUnsubscribed = true;\n\t        return empty;\n\t    }(new Subscription()));\n\t    return Subscription;\n\t})();\n\texports.Subscription = Subscription;\n\t//# sourceMappingURL=Subscription.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar SymbolShim_1 = __webpack_require__(11);\n\t/**\n\t * rxSubscriber symbol is a symbol for retreiving an \"Rx safe\" Observer from an object\n\t * \"Rx safety\" can be defined as an object that has all of the traits of an Rx Subscriber,\n\t * including the ability to add and remove subscriptions to the subscription chain and\n\t * guarantees involving event triggering (can't \"next\" after unsubscription, etc).\n\t */\n\texports.rxSubscriber = SymbolShim_1.SymbolShim.for('rxSubscriber');\n\t//# sourceMappingURL=rxSubscriber.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar root_1 = __webpack_require__(12);\n\tfunction polyfillSymbol(root) {\n\t    var Symbol = ensureSymbol(root);\n\t    ensureIterator(Symbol, root);\n\t    ensureObservable(Symbol);\n\t    ensureFor(Symbol);\n\t    return Symbol;\n\t}\n\texports.polyfillSymbol = polyfillSymbol;\n\tfunction ensureFor(Symbol) {\n\t    if (!Symbol.for) {\n\t        Symbol.for = symbolForPolyfill;\n\t    }\n\t}\n\texports.ensureFor = ensureFor;\n\tvar id = 0;\n\tfunction ensureSymbol(root) {\n\t    if (!root.Symbol) {\n\t        root.Symbol = function symbolFuncPolyfill(description) {\n\t            return \"@@Symbol(\" + description + \"):\" + id++;\n\t        };\n\t    }\n\t    return root.Symbol;\n\t}\n\texports.ensureSymbol = ensureSymbol;\n\tfunction symbolForPolyfill(key) {\n\t    return '@@' + key;\n\t}\n\texports.symbolForPolyfill = symbolForPolyfill;\n\tfunction ensureIterator(Symbol, root) {\n\t    if (!Symbol.iterator) {\n\t        if (typeof Symbol.for === 'function') {\n\t            Symbol.iterator = Symbol.for('iterator');\n\t        }\n\t        else if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n\t            // Bug for mozilla version\n\t            Symbol.iterator = '@@iterator';\n\t        }\n\t        else if (root.Map) {\n\t            // es6-shim specific logic\n\t            var keys = Object.getOwnPropertyNames(root.Map.prototype);\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var key = keys[i];\n\t                if (key !== 'entries' && key !== 'size' && root.Map.prototype[key] === root.Map.prototype['entries']) {\n\t                    Symbol.iterator = key;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            Symbol.iterator = '@@iterator';\n\t        }\n\t    }\n\t}\n\texports.ensureIterator = ensureIterator;\n\tfunction ensureObservable(Symbol) {\n\t    if (!Symbol.observable) {\n\t        if (typeof Symbol.for === 'function') {\n\t            Symbol.observable = Symbol.for('observable');\n\t        }\n\t        else {\n\t            Symbol.observable = '@@observable';\n\t        }\n\t    }\n\t}\n\texports.ensureObservable = ensureObservable;\n\texports.SymbolShim = polyfillSymbol(root_1.root);\n\t//# sourceMappingURL=SymbolShim.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(module, global) {var objectTypes = {\n\t    'boolean': false,\n\t    'function': true,\n\t    'object': true,\n\t    'number': false,\n\t    'string': false,\n\t    'undefined': false\n\t};\n\texports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n\t/* tslint:disable:no-unused-variable */\n\tvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\tvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\tvar freeGlobal = objectTypes[typeof global] && global;\n\tif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n\t    exports.root = freeGlobal;\n\t}\n\t//# sourceMappingURL=root.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(13)(module), (function() { return this; }())))\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Observable_1 = __webpack_require__(4);\n\tvar fromEvent_1 = __webpack_require__(15);\n\tObservable_1.Observable.fromEvent = fromEvent_1.FromEventObservable.create;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __extends = (this && this.__extends) || function (d, b) {\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\t    function __() { this.constructor = d; }\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t};\n\tvar Observable_1 = __webpack_require__(4);\n\tvar tryCatch_1 = __webpack_require__(16);\n\tvar errorObject_1 = __webpack_require__(17);\n\tvar Subscription_1 = __webpack_require__(9);\n\tvar FromEventObservable = (function (_super) {\n\t    __extends(FromEventObservable, _super);\n\t    function FromEventObservable(sourceObj, eventName, selector) {\n\t        _super.call(this);\n\t        this.sourceObj = sourceObj;\n\t        this.eventName = eventName;\n\t        this.selector = selector;\n\t    }\n\t    FromEventObservable.create = function (sourceObj, eventName, selector) {\n\t        return new FromEventObservable(sourceObj, eventName, selector);\n\t    };\n\t    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n\t        var unsubscribe;\n\t        var tag = sourceObj.toString();\n\t        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {\n\t            for (var i = 0, len = sourceObj.length; i < len; i++) {\n\t                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n\t            }\n\t        }\n\t        else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {\n\t            sourceObj.addEventListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n\t        }\n\t        else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {\n\t            sourceObj.on(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n\t        }\n\t        else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {\n\t            sourceObj.addListener(eventName, handler);\n\t            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n\t        }\n\t        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n\t    };\n\t    FromEventObservable.prototype._subscribe = function (subscriber) {\n\t        var sourceObj = this.sourceObj;\n\t        var eventName = this.eventName;\n\t        var selector = this.selector;\n\t        var handler = selector ? function (e) {\n\t            var result = tryCatch_1.tryCatch(selector)(e);\n\t            if (result === errorObject_1.errorObject) {\n\t                subscriber.error(result.e);\n\t            }\n\t            else {\n\t                subscriber.next(result);\n\t            }\n\t        } : function (e) { return subscriber.next(e); };\n\t        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n\t    };\n\t    return FromEventObservable;\n\t})(Observable_1.Observable);\n\texports.FromEventObservable = FromEventObservable;\n\t//# sourceMappingURL=fromEvent.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar errorObject_1 = __webpack_require__(17);\n\tvar tryCatchTarget;\n\tfunction tryCatcher() {\n\t    try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t    }\n\t    catch (e) {\n\t        errorObject_1.errorObject.e = e;\n\t        return errorObject_1.errorObject;\n\t    }\n\t}\n\tfunction tryCatch(fn) {\n\t    tryCatchTarget = fn;\n\t    return tryCatcher;\n\t}\n\texports.tryCatch = tryCatch;\n\t;\n\t//# sourceMappingURL=tryCatch.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\texports.errorObject = { e: {} };\n\t//# sourceMappingURL=errorObject.js.map\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wsabi-client.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d4a3d0cd55581f0468da\n **/","import {WsabiSocket} from \"./src/socket\";\r\nimport {WsabiClient} from \"./src/client\";\r\n\r\nexport {WsabiSocket, WsabiClient};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./typescript/index.ts\n **/","import {EventEmitter} from \"events\";\r\n\r\nexport class WsabiSocket extends EventEmitter {\r\n  public static WebSocket = typeof(WebSocket) === \"function\" ? WebSocket : undefined;\r\n  private static messageRegex = /(\\d)(\\d*)(.*)/;\r\n\r\n  private _socket: WebSocket;\r\n  private messageId = 0;\r\n  private waiting: {\r\n    [key: string]: (data: any) => void;\r\n  } = {};\r\n  private reconnecting: boolean = false;\r\n\r\n  constructor(public url: string) {\r\n    super();\r\n  }\r\n\r\n  connect() {\r\n    this._socket = new WsabiSocket.WebSocket(`${this.url}/socket.io/?transport=websocket&__sails_io_sdk_version=0.11.0`);\r\n    this._socket.addEventListener(\"open\", () => {\r\n      this.ping();\r\n    });\r\n    this._socket.addEventListener(\"message\", (res) => this._handleSocketMessage(res.data));\r\n    this._socket.addEventListener(\"close\", (res) => {\r\n      this.reconnecting = true;\r\n      setTimeout(() => {\r\n        this.connect();\r\n      }, 10000);\r\n    });\r\n    this._socket.addEventListener(\"error\", (res) => {\r\n      console.log(\"ERROR:\", res);\r\n    });\r\n  }\r\n\r\n  close() {\r\n    this._socket.close();\r\n  }\r\n\r\n  private _handleSocketMessage(res: string) {\r\n    let match = WsabiSocket.messageRegex.exec(res);\r\n    switch (parseInt(match[1])) {\r\n      case 0:\r\n        if (this.reconnecting) {\r\n          this.reconnecting = false;\r\n          this.emit(\"reopen\");\r\n        }\r\n        this.emit(\"open\");\r\n        break;\r\n      case 1:\r\n        this.close();\r\n        break;\r\n      case 3:\r\n        this.emit(\"pong\");\r\n        break;\r\n      case 4:\r\n        let type = parseInt(match[2][0]);\r\n        let id = parseInt(match[2].slice(1));\r\n        let data;\r\n        try {\r\n          data = JSON.parse(match[3]);\r\n        } catch (_) {\r\n          data = match[3];\r\n        }\r\n\r\n        this._handleMessagePacket(type, id, data);\r\n        break;\r\n      default:\r\n        console.warn(\"Unsupported packet id\", match[1]);\r\n    }\r\n  }\r\n\r\n  private _handleMessagePacket(type: number, id: number, data: any) {\r\n    switch (type) {\r\n      case 2:\r\n        if (Array.isArray(data) && data.length == 2) {\r\n          this.emit(data[0], data[1]);\r\n        } else {\r\n          this.emit(\"message\", data);\r\n        }\r\n        break;\r\n      case 3:\r\n        if (this.waiting[id] != null) {\r\n          this.waiting[id].call(this, data);\r\n          delete this.waiting[id];\r\n        } else {\r\n          this.emit(\"response\", {\r\n            id: id,\r\n            data: data\r\n          });\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  private ping() {\r\n    if (this._socket.readyState === WsabiSocket.WebSocket.OPEN) {\r\n      this._socket.send(\"2\");\r\n      setTimeout(() => {\r\n        this.ping();\r\n      }, 50000);\r\n    }\r\n  }\r\n\r\n  public send(data: any, callback?: (data: any) => void) {\r\n    let id = ++this.messageId;\r\n    if (callback != null) {\r\n      this.wait(id, callback);\r\n    }\r\n\r\n    this._socket.send(`42${id}` + JSON.stringify(data));\r\n  }\r\n\r\n  public wait(id: number, callback?: (data: any) => void) {\r\n    this.waiting[id] = callback;\r\n  }\r\n  \r\n  public isConnected() {\r\n    return this._socket.readyState === this._socket.OPEN;\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./typescript/src/socket.ts\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 2\n ** module chunks = 0 1\n **/","import {WsabiSocket} from \"./socket\";\r\nimport {Observable} from \"rxjs/Observable\";\r\n\r\nimport \"rxjs/add/observable/fromEvent\";\r\n\r\nexport class WsabiClient {\r\n  public static Promise = typeof(Promise) === \"function\" ? Promise : undefined;\r\n\r\n  public socket: WsabiSocket;\r\n  public liveUrl: string = \"/live\";\r\n  public logging: boolean = true;\r\n\r\n  private subscriptions: {\r\n    [key: string]: Observable<any>\r\n  } = {};\r\n\r\n  constructor(url: string, autoConnect: boolean = true) {\r\n    this.socket = new WsabiSocket(url);\r\n    this.socket.on(\"reopen\", () => {\r\n      let slugs = Object.keys(this.subscriptions);\r\n      for (let i = 0, len = slugs.length; i < len; i++) {\r\n        this.put(this.liveUrl, {slug: slugs[i]});\r\n      }\r\n    })\r\n\r\n    if (autoConnect) {\r\n      this.connect();\r\n    }\r\n  }\r\n\r\n  public connect() {\r\n    this.socket.connect();\r\n  }\r\n\r\n  public request(method: string, url: string, data: any = {}, headers: any = {}) {\r\n    return new WsabiClient.Promise((resolve, reject) => {\r\n      if (!this.socket.isConnected()) {\r\n        this.socket.once(\"open\", () => {\r\n          this.socket.send([\r\n            method,\r\n            {\r\n              method: method,\r\n              headers: headers,\r\n              url: url,\r\n              data: data\r\n            }\r\n          ], (data) => {\r\n            if (data[0].statusCode != 200) {\r\n              reject(data[0]);\r\n            } else {\r\n              resolve(data);\r\n            }\r\n          });\r\n        })\r\n      } else {\r\n        this.socket.send([\r\n          method,\r\n          {\r\n            method: method,\r\n            headers: headers,\r\n            url: url,\r\n            data: data\r\n          }\r\n        ], (data) => {\r\n          if (data[0].statusCode != 200) {\r\n            reject(data[0]);\r\n          } else {\r\n            resolve(data);\r\n          }\r\n        });\r\n      }\r\n    }).then(function (res) {\r\n      return res[0];\r\n    });\r\n  }\r\n\r\n  public get(url: string, headers: any = {}) {\r\n    return this.request(\"get\", url, {}, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public post(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"post\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public put(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"put\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public delete(url: string, data: any, headers: any = {}) {\r\n    return this.request(\"delete\", url, data, headers).then(function (res) {\r\n      return res.body;\r\n    });\r\n  }\r\n\r\n  public live(slug: string): Observable<any> {\r\n    if (!this.subscriptions.hasOwnProperty(slug)) {\r\n      this.subscriptions[slug] = Observable.fromEvent(this.socket, slug);\r\n      this.put(this.liveUrl, {slug: slug}).then((res) => {\r\n        if (this.logging) {\r\n          console.log(\"[Wsabi]\", `[${slug}]`, res.message || res);\r\n        }\r\n      })\r\n    }\r\n\r\n    return this.subscriptions[slug];\r\n  }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./typescript/src/client.ts\n **/","var Subscriber_1 = require('./Subscriber');\nvar root_1 = require('./util/root');\nvar SymbolShim_1 = require('./util/SymbolShim');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is\n     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify\n     * of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @returns {Observable} a new observable with the Operator applied\n     * @description creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @method Symbol.observable\n     * @returns {Observable} this instance of the observable\n     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     */\n    Observable.prototype[SymbolShim_1.SymbolShim.observable] = function () {\n        return this;\n    };\n    /**\n     * @method subscribe\n     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @returns {Subscription} a subscription reference to the registered handlers\n     * @description registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var subscriber;\n        if (observerOrNext && typeof observerOrNext === 'object') {\n            if (observerOrNext instanceof Subscriber_1.Subscriber) {\n                subscriber = observerOrNext;\n            }\n            else if (observerOrNext[rxSubscriber_1.rxSubscriber]) {\n                subscriber = observerOrNext[rxSubscriber_1.rxSubscriber]();\n            }\n            else {\n                subscriber = new Subscriber_1.Subscriber(observerOrNext);\n            }\n        }\n        else {\n            var next = observerOrNext;\n            subscriber = Subscriber_1.Subscriber.create(next, error, complete);\n        }\n        subscriber.add(this._subscribe(subscriber));\n        return subscriber;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {any} [thisArg] a `this` context for the `next` handler function\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @returns {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, thisArg, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        var nextHandler;\n        if (thisArg) {\n            nextHandler = function nextHandlerFn(value) {\n                var _a = nextHandlerFn, thisArg = _a.thisArg, next = _a.next;\n                return next.call(thisArg, value);\n            };\n            nextHandler.thisArg = thisArg;\n            nextHandler.next = next;\n        }\n        else {\n            nextHandler = next;\n        }\n        var promiseCallback = function promiseCallbackFn(resolve, reject) {\n            var _a = promiseCallbackFn, source = _a.source, nextHandler = _a.nextHandler;\n            source.subscribe(nextHandler, reject, resolve);\n        };\n        promiseCallback.source = this;\n        promiseCallback.nextHandler = nextHandler;\n        return new PromiseCtor(promiseCallback);\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source._subscribe(this.operator.call(subscriber));\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * @static\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @returns {Observable} a new cold observable\n     * @description creates a new cold Observable by calling the Observable constructor\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n})();\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observable.js\n ** module id = 4\n ** module chunks = 0 1\n **/","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar noop_1 = require('./util/noop');\nvar throwError_1 = require('./util/throwError');\nvar tryOrOnError_1 = require('./util/tryOrOnError');\nvar Subscription_1 = require('./Subscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        _super.call(this);\n        this.destination = destination;\n        this._isUnsubscribed = false;\n        if (!this.destination) {\n            return;\n        }\n        var subscription = destination._subscription;\n        if (subscription) {\n            this._subscription = subscription;\n        }\n        else if (destination instanceof Subscriber) {\n            this._subscription = destination;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return this;\n    };\n    Object.defineProperty(Subscriber.prototype, \"isUnsubscribed\", {\n        get: function () {\n            var subscription = this._subscription;\n            if (subscription) {\n                // route to the shared Subscription if it exists\n                return this._isUnsubscribed || subscription.isUnsubscribed;\n            }\n            else {\n                return this._isUnsubscribed;\n            }\n        },\n        set: function (value) {\n            var subscription = this._subscription;\n            if (subscription) {\n                // route to the shared Subscription if it exists\n                subscription.isUnsubscribed = Boolean(value);\n            }\n            else {\n                this._isUnsubscribed = Boolean(value);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber();\n        subscriber._next = (typeof next === 'function') && tryOrOnError_1.tryOrOnError(next) || noop_1.noop;\n        subscriber._error = (typeof error === 'function') && error || throwError_1.throwError;\n        subscriber._complete = (typeof complete === 'function') && complete || noop_1.noop;\n        return subscriber;\n    };\n    Subscriber.prototype.add = function (sub) {\n        // route add to the shared Subscription if it exists\n        var _subscription = this._subscription;\n        if (_subscription) {\n            _subscription.add(sub);\n        }\n        else {\n            _super.prototype.add.call(this, sub);\n        }\n    };\n    Subscriber.prototype.remove = function (sub) {\n        // route remove to the shared Subscription if it exists\n        if (this._subscription) {\n            this._subscription.remove(sub);\n        }\n        else {\n            _super.prototype.remove.call(this, sub);\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this._isUnsubscribed) {\n            return;\n        }\n        else if (this._subscription) {\n            this._isUnsubscribed = true;\n        }\n        else {\n            _super.prototype.unsubscribe.call(this);\n        }\n    };\n    Subscriber.prototype._next = function (value) {\n        var destination = this.destination;\n        if (destination.next) {\n            destination.next(value);\n        }\n    };\n    Subscriber.prototype._error = function (err) {\n        var destination = this.destination;\n        if (destination.error) {\n            destination.error(err);\n        }\n    };\n    Subscriber.prototype._complete = function () {\n        var destination = this.destination;\n        if (destination.complete) {\n            destination.complete();\n        }\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isUnsubscribed) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isUnsubscribed) {\n            this._error(err);\n            this.unsubscribe();\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isUnsubscribed) {\n            this._complete();\n            this.unsubscribe();\n        }\n    };\n    return Subscriber;\n})(Subscription_1.Subscription);\nexports.Subscriber = Subscriber;\n//# sourceMappingURL=Subscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscriber.js\n ** module id = 5\n ** module chunks = 0 1\n **/","/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/noop.js\n ** module id = 6\n ** module chunks = 0 1\n **/","function throwError(e) { throw e; }\nexports.throwError = throwError;\n//# sourceMappingURL=throwError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/throwError.js\n ** module id = 7\n ** module chunks = 0 1\n **/","function tryOrOnError(target) {\n    function tryCatcher() {\n        try {\n            tryCatcher.target.apply(this, arguments);\n        }\n        catch (e) {\n            this.error(e);\n        }\n    }\n    tryCatcher.target = target;\n    return tryCatcher;\n}\nexports.tryOrOnError = tryOrOnError;\n//# sourceMappingURL=tryOrOnError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryOrOnError.js\n ** module id = 8\n ** module chunks = 0 1\n **/","var noop_1 = require('./util/noop');\nvar Subscription = (function () {\n    function Subscription(_unsubscribe) {\n        this.isUnsubscribed = false;\n        if (_unsubscribe) {\n            this._unsubscribe = _unsubscribe;\n        }\n    }\n    Subscription.prototype._unsubscribe = function () {\n        noop_1.noop();\n    };\n    Subscription.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var unsubscribe = this._unsubscribe;\n        var subscriptions = this._subscriptions;\n        this._subscriptions = void 0;\n        if (unsubscribe) {\n            unsubscribe.call(this);\n        }\n        if (subscriptions != null) {\n            var index = -1;\n            var len = subscriptions.length;\n            while (++index < len) {\n                subscriptions[index].unsubscribe();\n            }\n        }\n    };\n    Subscription.prototype.add = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to add our this\n        //  3. we're attempting to add the static `empty` Subscription\n        if (!subscription || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var sub = subscription;\n        switch (typeof subscription) {\n            case 'function':\n                sub = new Subscription(subscription);\n            case 'object':\n                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.isUnsubscribed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    var subscriptions = this._subscriptions || (this._subscriptions = []);\n                    subscriptions.push(sub);\n                }\n                break;\n            default:\n                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');\n        }\n    };\n    Subscription.prototype.remove = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to remove ourthis\n        //  3. we're attempting to remove the static `empty` Subscription\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.isUnsubscribed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n})();\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscription.js\n ** module id = 9\n ** module chunks = 0 1\n **/","var SymbolShim_1 = require('../util/SymbolShim');\n/**\n * rxSubscriber symbol is a symbol for retreiving an \"Rx safe\" Observer from an object\n * \"Rx safety\" can be defined as an object that has all of the traits of an Rx Subscriber,\n * including the ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription, etc).\n */\nexports.rxSubscriber = SymbolShim_1.SymbolShim.for('rxSubscriber');\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/rxSubscriber.js\n ** module id = 10\n ** module chunks = 0 1\n **/","var root_1 = require('./root');\nfunction polyfillSymbol(root) {\n    var Symbol = ensureSymbol(root);\n    ensureIterator(Symbol, root);\n    ensureObservable(Symbol);\n    ensureFor(Symbol);\n    return Symbol;\n}\nexports.polyfillSymbol = polyfillSymbol;\nfunction ensureFor(Symbol) {\n    if (!Symbol.for) {\n        Symbol.for = symbolForPolyfill;\n    }\n}\nexports.ensureFor = ensureFor;\nvar id = 0;\nfunction ensureSymbol(root) {\n    if (!root.Symbol) {\n        root.Symbol = function symbolFuncPolyfill(description) {\n            return \"@@Symbol(\" + description + \"):\" + id++;\n        };\n    }\n    return root.Symbol;\n}\nexports.ensureSymbol = ensureSymbol;\nfunction symbolForPolyfill(key) {\n    return '@@' + key;\n}\nexports.symbolForPolyfill = symbolForPolyfill;\nfunction ensureIterator(Symbol, root) {\n    if (!Symbol.iterator) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.iterator = Symbol.for('iterator');\n        }\n        else if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n            // Bug for mozilla version\n            Symbol.iterator = '@@iterator';\n        }\n        else if (root.Map) {\n            // es6-shim specific logic\n            var keys = Object.getOwnPropertyNames(root.Map.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (key !== 'entries' && key !== 'size' && root.Map.prototype[key] === root.Map.prototype['entries']) {\n                    Symbol.iterator = key;\n                    break;\n                }\n            }\n        }\n        else {\n            Symbol.iterator = '@@iterator';\n        }\n    }\n}\nexports.ensureIterator = ensureIterator;\nfunction ensureObservable(Symbol) {\n    if (!Symbol.observable) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.observable = Symbol.for('observable');\n        }\n        else {\n            Symbol.observable = '@@observable';\n        }\n    }\n}\nexports.ensureObservable = ensureObservable;\nexports.SymbolShim = polyfillSymbol(root_1.root);\n//# sourceMappingURL=SymbolShim.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/SymbolShim.js\n ** module id = 11\n ** module chunks = 0 1\n **/","var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n/* tslint:disable:no-unused-variable */\nvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\nvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/root.js\n ** module id = 12\n ** module chunks = 0 1\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 13\n ** module chunks = 0 1\n **/","var Observable_1 = require('../../Observable');\nvar fromEvent_1 = require('../../observable/fromEvent');\nObservable_1.Observable.fromEvent = fromEvent_1.FromEventObservable.create;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/add/observable/fromEvent.js\n ** module id = 14\n ** module chunks = 0 1\n **/","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar tryCatch_1 = require('../util/tryCatch');\nvar errorObject_1 = require('../util/errorObject');\nvar Subscription_1 = require('../Subscription');\nvar FromEventObservable = (function (_super) {\n    __extends(FromEventObservable, _super);\n    function FromEventObservable(sourceObj, eventName, selector) {\n        _super.call(this);\n        this.sourceObj = sourceObj;\n        this.eventName = eventName;\n        this.selector = selector;\n    }\n    FromEventObservable.create = function (sourceObj, eventName, selector) {\n        return new FromEventObservable(sourceObj, eventName, selector);\n    };\n    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber) {\n        var unsubscribe;\n        var tag = sourceObj.toString();\n        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {\n            for (var i = 0, len = sourceObj.length; i < len; i++) {\n                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);\n            }\n        }\n        else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {\n            sourceObj.addEventListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeEventListener(eventName, handler); };\n        }\n        else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {\n            sourceObj.on(eventName, handler);\n            unsubscribe = function () { return sourceObj.off(eventName, handler); };\n        }\n        else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {\n            sourceObj.addListener(eventName, handler);\n            unsubscribe = function () { return sourceObj.removeListener(eventName, handler); };\n        }\n        subscriber.add(new Subscription_1.Subscription(unsubscribe));\n    };\n    FromEventObservable.prototype._subscribe = function (subscriber) {\n        var sourceObj = this.sourceObj;\n        var eventName = this.eventName;\n        var selector = this.selector;\n        var handler = selector ? function (e) {\n            var result = tryCatch_1.tryCatch(selector)(e);\n            if (result === errorObject_1.errorObject) {\n                subscriber.error(result.e);\n            }\n            else {\n                subscriber.next(result);\n            }\n        } : function (e) { return subscriber.next(e); };\n        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);\n    };\n    return FromEventObservable;\n})(Observable_1.Observable);\nexports.FromEventObservable = FromEventObservable;\n//# sourceMappingURL=fromEvent.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/fromEvent.js\n ** module id = 15\n ** module chunks = 0 1\n **/","var errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryCatch.js\n ** module id = 16\n ** module chunks = 0 1\n **/","exports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/errorObject.js\n ** module id = 17\n ** module chunks = 0 1\n **/"],"sourceRoot":""}